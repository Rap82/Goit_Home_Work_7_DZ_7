# ===================  Home work 7 ========================

# =================== Створення та встановлення власних пакетів ==========================

# Модуль, що містить інструкції по установці, викликає функцію setup з пакету setuptools. 
# Функція setup робить установку пакету в системі і містить параметри, що конфігурують установку.

# Детальні інструкції по написанню setup.py ви можете отримати на сторінці документації.

# Приклад вмісту setup.py:

# from setuptools import setup

# setup(name='useful',
#       version='1',
#       description='Very useful code',
#       url='http://github.com/dummy_user/useful',
#       author='Flying Circus',
#       author_email='flyingcircus@example.com',
#       license='MIT',
#       packages=['useful'])
# В даному прикладі ми викликаємо setup з додатковими інформаційними параметрами, які будуть доступні користувачам. 
# А саме, ми вказали ім'я пакету, версію, короткий опис пакету, адресу, де можна подивитися початковий код, ім'я автора, 
# його email, ліцензію, набір пакетів, які включені у поставку.

# Що якщо наш пакет досить великий і прописувати вручну усі модулі packages незручно і існує ризик помилитися? 
# Тоді у setuptools є функція find_namespace_packages, яка допоможе знайти всі модулі і не пропустити нічого:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages()
# )
# Такий пакет можна опублікувати на PyPi і тоді його можна буде встановити за допомогою pip, 
# або опублікувати початковий код і тоді можна буде встановити з початкових кодів.

# Щоб встановити цей пакет з початкового коду, виконайте в консолі pip install . або pip install -e . у папці, де лежить setup.py


# ================================ Звдання 1 / Task 1 ======================================

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для ініціалізації свого проекту створіть допоміжну функцію do_setup(args_dict), яка буде викликати функцію setup з параметрами 
# зі словника args_dict.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }

# ++++++++++++++++++++++++++++++++++  Код /Code  +++++++++++++++++++++++++++++++++++++++++++++++++


# args_dict = {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# } # Тестовий словник який має структуру яка відповідає умовам завдання.


# def do_setup ( args_dict ) : # Функція *do_setup ( args_dict )- для виклику функції *setup ( **args_dict )
#                              # Приймає один аргумент  словник  *args_dict - вказаного формату . З параметрами цього словника буде виклки функції setup ( **args_dict )   
    
#     setup ( **args_dict )   # Функція яка приймає як аргументи значення з словника і співставляє їх по порядку з значеннями описаними в самій функції  def setup (...)- дивись опис функції в коді нижче.
#                             # Важливо : щоб в описі функції *def setup(...) , Було стільки аргумантів скільки в словнику ключів *args_dict ,
#                             # *setup ( **args_dict ) - такий запис рівноціний в ручну створеному запису   *setup (name = args_dict['name'] , version=args_dict['version'] , description=args_dict['description'], url=args_dict['url'], author=args_dict['author'], author_email=args_dict['author_email'],license=args_dict['license'] ,packages=args_dict['packages'] )
#                             # де перший аргумент *name переданий у функцію *setup() отримає значення взяте з нашого словника *args_dict за ключем *'name'
#                             # другий аргумент *version переданий у функцію *setup() отримає значення взяте з нашого словника *args_dict за ключем *'version'
#                             # і так далі. Щоб обійти явне задавання аргументів можна зробити запис **імя_зміної- де дві зірочки "**" - це означає всі значення . імя_зміної - це імя змінної що буде містити множину  значень (тип list, dict, set , tuple -та інші )
    
    


# # def setup ( **_ ) :  # Якщо кількість аргументів і їх імена ,які будуть передані ,наперед невідомо можна їх записати у вигляді  (**_ )
# #                      # Де '**'- множина значень .'_' - одинокий символ підкреслення - це в пайтон позначення будь якої зміної імя якої наперед невідомо.

# #     for elemet,value in _.items() :  # Ми можемо також працювати з наперед невизначеним аргументом якщо його тип буде відповідати тому що ми хочемо з ним зробити.
# #                                      # в нашому випадку *setup ( **args_dict ) . **args_dict- це множина типу словник . Тому ми можемо скористатись всіма методами і способами  які достіпні для роботи з словниками
# #                                      # В нашому випадку ми будемо в циклі for проходитись по всіх ключах і значеннях з невідомого наперед словника і принтити ключ і відповідне значення попорядку. 
# #         print (elemet)
# #         print (value)
    
    

# # # def setup (name , version , description , url, author, author_email, license, packages ) : # Функція  з наперед відомими аргументами. і явно оголошеними . Сформована тільки під цей конкретний випадок .
# #                                                                                              # def setup ( **_ ) : - такий запит є універсальний якщо наперед невідомом ні кількість значень ні назву зміної.

# #     #  print (name , version , description , url, author, author_email, license, packages )

    
# # do_setup (args_dict)  # виклик функції *do_setup (args_dict)


# ================================ Звдання 2 / Task 2 ======================================

# Якщо в нашому пакеті є залежності, щоб він запрацював, потрібно встановити додаткові пакети, треба їх всі прописати в параметрі install_requires:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages(),
#     install_requires=['markdown']
# )
# В цьому прикладі наш пакет буде вимагати встановити спочатку пакет markdown перед встановленням. 
# Порядок встановлення залежностей визначає сам менеджер пакетів (pip наприклад).


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Модифікуємо приклад попередньої задачі. Для функції do_setup необхідно передбачити другий параметр, який буде списком залежностей.

# Функція do_setup(args_dict, requires) повинна викликати функцію setup з параметрами зі словника args_dict та параметром install_requires,
# який набуває значення requires.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }

# ++++++++++++++++++++++++++++++++++  Код /Code  +++++++++++++++++++++++++++++++++++++++++++++++++

# from setuptools import setup # для VScode цей імпорт оки непотрібний. Видає зараз помилку мабудь неістальвана ця біліотека наразі в мене.

# args_dict = {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
#             }  # Тестовий словник який має структуру яка відповідає умовам завдання.

# def do_setup ( args_dict, requires ) :  # Функція *do_setup ( args_dict )- для виклику функції *setup ( **args_dict )
#                                     # Приймає Два аргумента, Перший словник *args_dict а інший  - значення *requires які тереба добавити в нашу функцію *septup(**args_dict ) для нового параметру *install_requires
#                                     # Дане питання закриваэмо ти що просто добавляэмо в наш словник *args_dict який передасться в функцію  do_setup(args_dict, requires) новий ключ *install_requires  і його значення *requires
#                                     # Добавляємо новий ключ і значення внаш словник методом *імя_словника.update({'ключ': *значення})

#     args_dict.update ( { 'install_requires': requires } ) # Метод .update({'key': value})- записує в наш словник нову пару ключ : значення в кінець словника.
#                                                           #  args_dict.update({'install_requires': requires}) - в нашому випадку до словника *args_dict в кінці добавить  ключ 'install_requires' з значенням *requires

#     setup ( **args_dict )  # Виклик функції *setup ( **args_dict ) 
   


# def setup ( **_ ) :  # Якщо кількість аргументів і їх імена ,які будуть передані ,наперед невідомо можна їх записати у вигляді  (**_ )
#                      # Де '**'- множина значень .'_' - одинокий символ підкреслення - це в пайтон позначення будь якої зміної імя якої наперед невідомо.

#     for elemet,value in _.items() :  # Ми можемо також працювати з наперед невизначеним аргументом якщо його тип буде відповідати тому що ми хочемо з ним зробити.
#                                      # в нашому випадку *setup ( **args_dict ) . **args_dict- це множина типу словник . Тому ми можемо скористатись всіма методами і способами  які достіпні для роботи з словниками
#                                      # В нашому випадку ми будемо в циклі for проходитись по всіх ключах і значеннях з невідомого наперед словника і принтити ключ і відповідне значення попорядку. 
#         print ( elemet )  # Принтанути поточний ключ з переданого в функцію словника
#         print ( value )   # # Принтанути відповідне  поточне значення з переданого в функцію словника . 
#                             # Принтане всіключі і всі їх значення попорядку . Ключ і відповідне значення бо прінтемо в циклі for де попорядку  перебераємо пари ключ і занчення 

# requires = "fine"  # занчення для перевірки.

# do_setup ( args_dict, requires ) # Виклик функції *do_setup ( args_dict, requires ) 

#  ++++++++++++++++++++++++++++++++++  Код /Code для атопереврки +++++++++++++++++++++++++++++++++++++++++++++++++

# def do_setup ( args_dict, requires ) : 

#     args_dict.update ( { 'install_requires': requires } ) 

#     setup ( **args_dict )



# ================================ Звдання 3 / Task 3 ======================================

# Якщо наш пакет містить додаток, який можна викликати з консолі, зручно буде додати можливість виклику цього застосування 
# у будь-якому місці нашої системи з консолі. Для цього у виклику setup додамо ще один параметр — entry_points. 
# Цей параметр приймає словник, де ми можемо вказати список "точок входу" для ключа console_scripts.

# Наприклад, в нашому пакеті у модулі some_code.py є функція hello_world, яка виводить у консоль повідомлення Hello World!. 
# Після встановлення пакету ми зможемо у будь-якому місці нашої системи виконати в консолі команду: helloworld і отримаємо у відповідь Hello World!.

# Щоб це працювало в системі Python повинен викликатися при виклику файлів з розширенням .py та setup.py має бути змінений:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages(),
#     install_requires=['markdown'],
#     entry_points={'console_scripts': ['helloworld = useful.some_code:hello_world']}
# )
# У списку точок входу console_scripts можуть бути виконувані файли (.exe), скрипти Bash, cmd, PowerShell і будь-який інший файл,
# який операційна система зможе виконати.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Продовжуємо модифікувати приклад. Для функції do_setup необхідно передбачити третій параметр, який буде словником, 
# де ми можемо вказати список "точок входу" для ключа console_scripts.

# Функція do_setup(args_dict, requires, entry_points) повинна викликати функцію setup з параметрами словника args_dict 
# та параметром install_requires, який набуває значення requires. Третій параметр entry_points приймає словник, 
# де ми можемо вказати список "точок входу" для ключа console_scripts.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }


#  Алгоритм : вирішення просто обновляємо наш словник ще одним новою паролю ключ і значення відповідно до умови завдання.
# Завдання вчить як маючи почакткове сформоване значення для функції поповнювати новими аргументами за певним шаблоном.

#  ++++++++++++++++++++++++++++++++++  Код /Code для атопереврки +++++++++++++++++++++++++++++++++++++++++++++++++

# def do_setup ( args_dict, requires, entry_points ) :
#     args_dict.update ( { 'install_requires': requires } ) # записуємо в наш словник в кінці нову пар ключ і значення.
#     args_dict.update ( { 'entry_points': entry_points } ) # записуємо в наш словник в кінці нову пар ключ і значення.
#     setup ( **args_dict )  # Викликаєм функцію вже з оновленими аргументами і їх значеннями.


# ================================ Звдання 4 / Task 4 ======================================

# Далі підуть завдання на повторення та закріплення матеріалу. Можна використовувати будь-які техніки, з якими ви зіткнулися у процесі навчання. 
# І почнемо ми з функцій.

# Визначення функції починається з ключового слова def, після повинно йти ім'я функції, далі дужка (, потім дужка, що закриває ) 
# і знак двокрапки :. Тіло функції починається з нового рядка з необхідним відступом. Python вважає, що знайшов кінець тіла функції, 
# як тільки відступ у рядку стане такого ж рівня, як в оператора def.

# Тільки визначення функції не змусить код виконатись, необхідно виконати виклик функції.

# def hello():
#     print('Hello user!')


# hello()  # Hello user!
# Велику гнучкість функцій надає той факт, що вони можуть приймати аргументи через передачу їм значень у круглих дужках. 

# При виклику функції значення цих аргументів ініціалізують змінні параметрів. Параметри прописуються в круглих дужках під час оголошення функції. 
# Кількість параметрів визначає кількість аргументів, які передаються під час виклику функції.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# У Python існує рядкова функція isdigit(). Ця функція повертає True, якщо всі символи в рядку є цифрами, і є принаймні один символ, інакше — False.
# Напишіть функцію з ім'ям is_integer, яка розширюватиме функціональність isdigit(). 
# При перевірці рядка необхідно ігнорувати початкові та кінцеві прогалини в рядку.
# Після виключення зайвих прогалин рядок вважається таким, що представляє ціле число, якщо:

# її довжина більша або дорівнює одному символу
# вона повністю складається з цифр
# передбачити виняток, що, можливо, є початковий знак "+" або "-", після якого мають йти цифри

#  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# def is_integer( s ): # Функція приймає рядок (тип *str) видаляє всі пробіли з переді і з кінця рядка . Видаляє занк + або - на початку рядка 
    
#     s = s.strip ()  # Видаляємо всі пробіли на початку і в кінці рядка і овлений рядок перезаписуємо в наш рядок *s . Метод *імя_рядка.strip ()- без аргумету ,видаляє з нашого рядка (*імя_рядка) всі символи пробілів з почактку і з кінця .
#                     # Перевіряє чи є смиволи пробілів напочатку і в кінці рядка і видалє їх якщо вони є повертає рядок очищений від них. якщо немає ні напочатку ні накінці поверта назад незмінений рядок. Якщо пробіли зустрічаються в середені рядка то їх не видалє.
    
#     s = s.lstrip ("+") # Після того як позбулись пробілів видалємо символ "+" з початку рядка . Метод *.lstrip ("+") видалє всі символи які вказані як параметр  які йдуть підряд один за одним без пропусків. Якщо параметр невказаний *.lstrip ()- видалє всі пробіли напочатку рядка.
#     s = s.lstrip ("-") # # Після того як позбулись можлививх пробілів і можливого символа "+" з початку рядка . Видалємо можлививй симивол "-" тим самим методом тільки з парметром "-".  *.lstrip ("-")
   
#     if len(s) == 0:    # Перевірємо чи після наших змін в рядку *s -ще залишились якісь символи . Якщо рядок пустий . Значить повертає *False
#                        # якщо умова невиконається з начить в рядку ще залишились символи. Дальше вкоді перевіримо чи ті символи це тільки цифри.
       
#        return False    # Повертаємо з фнкції  is_integer( s ) - значення *False 
    
#     return s.isdigit() # Вже відформатований наш рядок *s  без пробілів на початку і в кінці , і без можлививх символів на початку + чи - Перевіряємо методом 

# s = "  +32  " # True # Тестові значення
# s = "32  " # True  # Тестові значення
# s = "32  3" # False # Тестові значення ( є пробіли в середені рядка.)
# s = "-+35" # False # Тестові значення ( в нашому випадку спочатку видалє + напочатку рядка а вцьому випадку рядок починаться з мінуса тому його не видалить і в рядку залишаться не цифри)
# s = "++-45" #True (за умовою має бути або "+"" або "-" і за одним із зних відразу   цифри,  для такого запису малоб повернути False про те повертає True але для автоперевіки підішло.Мабуть вних немає такого тестовго значення.))))

# print ( is_integer ( s ) ) # Притимо значення яке поверне функції *is_integer ( s )


# ================================ Звдання 5 / Task 5 ======================================


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Дуже часто люди у своїх повідомленнях не ставлять великі літери, особливо це стало масовим явищем в еру мобільних. пристроїв. 
# Розробіть функцію capital_text, яка прийматиме на вхід рядок з текстом і повертатиме рядок з відновленими великими літерами.

# Функція повинна:

# зробити великою першу літеру в рядку, попри прогалини
# зробити великою першу літеру після точки, попри прогалини
# зробити великою першу літеру після знака оклику, попри прогалини
# зробити великою першу літеру після знака питання, попри прогалини

#  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# def first_big_leter_split_point ( s ) : # Функція приймає один аргумент рядок і повертає новий  рядок . Де речення починається з великої букви  ігнорує всі пробіли на початку речення .
#                                         # Речення в рядку розділені крапкою . Фунція перевіряє всі речення які розділені карпкою в рядку і робить перше слово в речені з великої букви всі інші символи залишає без змін.


#     list_new_elem = []       # Список в який будемо збирати змінені речення для подальшого їх обєнання в рядок. Для поверненя з функції . Початкове значення пустий .
#     list_s = s.split ( '.' )  # Метод .slpit() приймає один аргумент . За цим аргумантом розбиває рядок і повертає список рядків розбитих за вказаним символом без символу по якому розбиває.
#                               # Для нашого зназення s поверне наступний список *ist_s = ['  віра  гуляла в саду ', ' по дорозі її зустрівся  знайомий хлопчик  ', '   привіт ! - сказала Віра ', ' як тебе звати ? петро -відповів хлопчик    ', '']
#     #print (list_s)
#     for  element in list_s : # В циклі проодимось по лементах списку . Де елементи будуть рядкі які утворилися після розділення по крапці.
       
#        space = " "  # space = знаку пробілу " "  Потрібний для відновлення початкового рядка якщо він починається з пробілів.
#        count = 0    # лічильник . Початкове значення 0 . Використаємо для підрахунку пробілів на початку кожного речення яке розділене Крапкою "."

#        for symvol in element : # Вкладений цикл. Проходимось по кожному символу з нашого рядка з утвореного списку після розділення методом  s.split ( '.' ) 
#            new_string = ""     # Рядок в який будемо записувати змінений рядок Вже звеликою першою буквою на початку рядка.
           
#            if symvol == " " :  # Перевірка чи перші символи рядка є пробілами . Якщо є ряхуємо скільки їх щоб в зміненому рядку їх дабавити на початку як і в оригінальному було.
               
#                count += 1      # Збільшує наш лічильник на 1 стільки раз скільки буде пробілів на початку речення. 
#                continue        # Оператор *continue ігнорує весь код нижче за себе поки спрацьовує умова if / . і повертає цик на наступну ітерацію.
           
#            #print(count)
        
#            new_elemet = element.lstrip()  # Видаляємо на початку поточного рядка всі пробіли . Вони вже ванс пораховані в *count і поки непотрібні.

#            list_new_element = new_elemet.split() # Розбиваємо наше речення яка вже починається з букви на окремі слова за знаком пробіл - " ".
           
#            list_new_element[0] = list_new_element[0].capitalize() # Перший елемент списку і буде наша перше слово в речені де потрібно зробити першу букву великою . Застосовуємо метод .capitalize() - робить першу літеру в рядку великою все інше перетворює в меланькі букви.
           
#            new_elem = " ".join ( list_new_element )   # Після того як порахували пробіли і зробили першу букву Великолою в першому слові речення склеюємо наш рядок назад функцією " ".join ( list_new_element ) де " " - символ пробілу  по якому склеюємо слова з списку *list_new_element .
#                                                        # Символ по якому склеює метод *str.join ( *list ) незаписується перед першим значенням з списку і після останього значення з списку. За потреби їх треба додавати окремо.

#            new_elem = space*count + new_elem  # Добавляємо спереді до нашого склеєного ряда ту кількість символів з зміної  *space яку нарахували в *count  щоб рядок був аналогічним орігінальному тільки вже з великою першою буквою впершому слові з  речень  розідених крапкою.
#            #print ( new_elem )
#            list_new_elem.append ( new_elem ) # Добавляємо всі речення в наш список з якого потім сформуємо рядок схожий на початковий тільки з великим першими літерами на пояатку кожного речення яке розділено крапкю.

#            break # Перериваємо вкладений цикл. Перебирати всі символи з речення немає змісту . все що треба ми виконали .
    
    
#     #print (list_new_elem)
#     new_string = ' .'.join ( list_new_elem )  # Після того як в циклі зібрали всеь список з наших речень з заміненими перших бук в словах на початку речення на великі . склеюємо нашіречення в оди рядок по символи яким їх розділяли.
#                                              #  В нашому випадку це було по крапці . Утворюємо початковий рядок переданий у функцію але вже з великими першими буквами в словах на початку кожного речення розділеного крапко.    return new_string
#     return new_string     # повертаємо з функції змінений рядок.
#     #print (new_string)

# def first_big_leter_split_question_mark ( s ) : # Функція робить все те саме що і first_big_leter_split_point ( s ) тільки розділяє і склеює пілся заміни на велику першої букви в першому слові на початку кожного речення по символу знак питання '?' .

#     list_new_elem = []
#     list_s = s.split ( '?' )
    
#     for  element in list_s :
#        space = " "
#        count = 0 

#        for symvol in element :
#            new_string = ""
           
#            if symvol == " " :
               
#                count += 1
#                continue
           
#            #print(count)
        
#            new_elemet = element.lstrip()

#            list_new_element = new_elemet.split()
           
#            list_new_element[0] = list_new_element[0].capitalize()
           
#            new_elem = " ".join ( list_new_element )

#            new_elem = space*count + new_elem
#            #print ( new_elem )
#            list_new_elem.append ( new_elem )
#            break
    
    
#     #print (list_new_elem)
#     new_string = ' ?'.join ( list_new_elem )
#     return new_string

# def first_big_leter_split_exclamation_mark ( s ) :  # Функція робить все те саме що і first_big_leter_split_point ( s ) тільки розділяє і склеює пілся заміни на велику першої букви в першому слові на початку кожного речення по символу знак питання '!' .

#     list_new_elem = []
#     list_s = s.split ( '!' )
    
#     for  element in list_s :
#        space = " "
#        count = 0 

#        for symvol in element :
#            new_string = ""
           
#            if symvol == " " :
               
#                count += 1
#                continue
           
#            #print(count)
        
#            new_elemet = element.lstrip()

#            list_new_element = new_elemet.split()
           
#            list_new_element[0] = list_new_element[0].capitalize()
           
#            new_elem = " ".join ( list_new_element )

#            new_elem = space*count + new_elem
#            #print ( new_elem )
#            list_new_elem.append ( new_elem )
#            break
    
    
#     #print (list_new_elem)
#     new_string = ' !'.join ( list_new_elem )
#     return new_string
       
                   
            
# def capital_text (s) : # jосновна фінкція . Приймає рядок в якому потрібно виконати всі зміни згідно умови завдання . І повернути змінений рядок за 3 критерями.
   
#     new_string = first_big_leter_split_point ( s ) # Опрацьовуємо отримани з функції *capital_text (s) вхідний рядок . Робимо відповідні зміни і повертаємо його назад. Зміни відбуваються в рядку по значеню крапка.

#     new_string = first_big_leter_split_question_mark ( new_string ) # Повернутий  з функції *first_big_leter_split_point ( s ) новий рядок опрацювуємо функцією *first_big_leter_split_question_mark ( new_string ) - змінений за символом "." новий рядок повертаємо 

#     new_string = first_big_leter_split_exclamation_mark ( new_string ) # Повернутуй з функції *first_big_leter_split_exclamation_mark ( new_string ) новий рядок опрацювуємо функцією first_big_leter_split_question_mark ( new_string ) - змінений за символом "!" новий рядок повертаємо 

#     new_string = new_string + " " + s[-1]  # Добавляємо до нашого зміненого рядка останій пробіл і останй символ з орігінального рядка щоб його невтрати.  де *s[-1]  останій символ орігінального рядка переданого в змінуоскільки в процесі роботи методу .join(*list) ми його втратимо.
    
#     return new_string # повертаємо змінений рядок зідно завдання.

             
  

# s = '  віра  гуляла в саду . по дорозі її зустрівся  знайомий хлопчик  .   привіт ! - сказала Віра . як тебе звати ? петро -відповів хлопчик    .' # Рядок запропонований для змін. Тестове значення.



# print ( capital_text (s) ) # Виклик фінкції *capital_text (s)

# # print ( first_big_leter_split_point ( s ) )
# # print (first_big_leter_split_question_mark ( s ))
# # print (first_big_leter_split_exclamation_mark ( s ))


# ================================ Звдання 6 / Task 6 ======================================

# Давайте повторимо теорію щодо зрізів у списків.

# Для впорядкованих контейнерів існує особливий синтаксис, щоб отримувати деякі послідовності елементів з контейнера.

# Наприклад, необхідно отримати перші 5 букв рядка:

# greeting = "Hello my little friend"
# hello = greeting[0:5]
# Змінна hello у цьому прикладі міститиме рядок 'Hello'.

# Синтаксис зрізу складається з трьох чисел, вказаних через двокрапку. 
# Перше число — це індекс першого елемента, який треба взяти для зрізу. 
# Друге число — це індекс, до якого (не включаючи його) брати елементи для нової послідовності. 
# І третє, воно за замовчуванням дорівнює одиниці, — це крок, з яким треба брати елементи у нову послідовність.

# Візьмімо список чисел від 1 до 10 і збережемо окремо парні, непарні та кратні 3.

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[0:9:2]
# even_numbers = numbers[1:9:2]
# three_numbers = numbers[2:9:3]
# odd_numbers — ми беремо числа, починаючи з індексу 0 до 9 з кроком у 2 (отримаємо [1, 3, 5, 7, 9])
# even_numbers — ми беремо числа, починаючи з індексу 1 до 9 з кроком у 2 (отримаємо [2, 4, 6, 8])
# three_numbers — ми беремо числа, починаючи з індексу 2 до 9 з кроком у 3 (отримаємо [3, 6, 9])
# Ви можете не вказувати початковий, кінцевий індекс чи крок, пропускаючи його. 
# За замовчуванням Python візьме зріз від початку до останнього елемента з кроком 1.

# Перепишемо попередній приклад у скороченому синтаксисі:

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[::2]
# even_numbers = numbers[1::2]
# three_numbers = numbers[2:9:3]

# numbers_copy = numbers[:]
# numbers_copy у цьому прикладі — це зріз, який бере всі елементи numbers від початку до кінця з кроком 1.

# Увага
# Важливо пам'ятати, що до зрізу не входить елемент з індексом, до якого треба брати елементи.

# numbers = [0, 1, 2, 3]
# first_three = numbers[0:3]  # [0, 1, 2]
# У цьому прикладі елемент 3 з індексом 3 не увійде до first_three.

# Цікаво
# Отримати список `numbers` у зворотному порядку допоможе `numbers[::-1]`

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Всі ви, можливо, стикалися з ребусами "Знайди слово". Вони існують як текстові варіанти, 
# так і як програми для мобільних додатків. Нагадаємо коротко суть ребуса. 
# У великому квадраті з набором букв необхідно знайти слово по горизонталі та інколи по вертикалі.

# game
# Реалізуйте функцію solve_riddle(riddle, word_length, start_letter, reverse=False) для знаходження слова, що шукається в рядку ребуса.

# Параметри функції:

# riddle - рядок із зашифрованим словом.
# word_length – довжина зашифрованого слова.
# start_letter - літера, з якої починається слово (мається на увазі, що до початку слова літера не зустрічається в рядку).
# reverse - вказує, у якому порядку записане слово. За замовчуванням — в прямому. Для значення True слово зашифроване 
# у зворотньому порядку, наприклад, у рядку 'mi1rewopret' зашифроване слово 'power'.
# Функція повинна повертати перше знайдене слово. Якщо слово не знайдене, повернути пустий рядок.

# Коментар  : Зашифрованим словом буде вважатиьсь будь який набір символів починаючи з символа start_letter і наступні за ним попорядку  (word_length - 1) .
#  або вправо від нього або вліво віднього в залежності від значення *reverse  . *True - формуємо слово з символів попорядку з права на ліво . False - з ліва на право .
# Слово буде важатись вірним якщо воно буде починатись з start_letter і містити сумарно word_length символів записаних в послідовність символів згідно умови.

##  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++



# def solve_riddle ( riddle, word_length, start_letter, reverse = False ) : # Функція яка  перевіряє чи є врядку *riddle символ *start_letter
#                                                                           # Якщо немає то відразу повертає пустий рядок *""
#                                                                           # Якщо є робить додаткову перевірку згідно вимог завдання .
#                                                                           # Якщо перевіркка відбувається успішно повертає слово яке відповідає критеріям пошуку вказаних в завдані .
#                                                                           # Читай коментар в (Умова / Condition )

#     latter_index = riddle.find ( start_letter )   #  Перевіряємо наш рядок  *riddle чи є в ньому *start_letter Методом *імя_рядка.find (*str, *[start],*[end])
#                                                   # Метод S.find (str, [start],[end]) повертає індек перешго найденого від початку рядка *символа/символів які шукаємо в рядку якщо такі найдуться .
#                                                   # Якщо такого  *символа/символів ненайде повертає *-1 .Може містити необовязкові параметри *[start] і *[end] 
#                                                   #  Де *[start] вказує на індекс смивола з рядка з якого почати пошук а *[end] на якому закінчити . Якщо їх невказувати то пошук проводиться по всьому рядку з початку в кінець посимвольно 
#                                                   #  Як тільки буде знайдено перший збіг ,метод поверне індекс знайденого символа з даного рядка чи його частини (якщо вказано параметри *[start] і *[end])       

#     print ( latter_index )

#     if latter_index >= 0 :                         # Умова основної переврки . Якщо latter_index = -1 значить Метод *riddle.find ( start_letter ) - не найшов жодного входження *start_letter в рядку *riddle 
#                                                    # Умова не виконається перйде на останій *else і повернем пустий рядок "" з функції  *solve_riddle ( riddle, word_length, start_letter, reverse = False )
#                                                    # Якщо *latter_index ,>= 0 Значить збіг знайшовся перевірємо чи виконаються інші умови завдання.
#         if reverse == False :                      # Умова якщо *reverse == False  значить шікаємо наше слово від start_letter і на довжину *word_length-1 з ліва на право.   

#             encode_word = riddle [ latter_index : latter_index + word_length ] # *encode_word - слово яке шукаємо . Наше слово це буде зріз з рядка *riddle [ latter_index : latter_index + word_length ] 
#                                                                                # де *riddle рядок з якого робимо зріз 
#                                                                                # *latter_index - символа *start_letter 
#                                                                                # *latter_index + word_length - до індекса символая який найшли добавляжмо довжену слова що шукаємо. 
            
#             if len ( encode_word ) == word_length :   # Перевіряємо чи слово що утворилось в результаті зрізу буде мати відповідну довжину .Якщо так то це є наше слово його і повртаємо. 
#                                                       # Якщо ні значить наше слово невірне повертаємо пустий рядок.   

#                 return encode_word                    # повертаємо наше слово яке відповідає умаві завдання  
            
#             else : 

#                 print ('пустий рядок ')

#                 return ""                            # повертаємо пустий рядок.Якщо умова *if len ( encode_word ) == word_length : - не виконалась

        
#         else :   # Якщо умова *if reverse == False : не виконалась. значить *reverse == True і пошук слова має відбутись з права на ліво від *start_letter 

#             encode_word = riddle[ latter_index  : latter_index - word_length :  -1] # Робимо перевернутий зріз 
            
            
#             if len ( encode_word ) == word_length :  # Перевіряємо чи слово що утворилось в результаті зрізу буде мати відповідну довжину .Якщо так то це є наше слово його і повртаємо. 

#                 return encode_word                   # повертаємо наше слово яке відповідає умаві завдання 
            
#             else :

#                 print('пустий рядок ')

#                 return ""                             # повертаємо пустий рядок.Якщо умова *if len ( encode_word ) == word_length : - не виконалась
#     else :
#         print('пустий рядок ')

#         return ""
    
  
    

    


# riddle = 'mi1rewopret'   # Тестове значення

# # riddle = 'mi1reworettttt' # Тестове значення

# word_length = 5 # Тестове значення

# start_letter = "p"   # Тестове значення
# # reverse = True       # Тестове значення
# reverse = False      # Тестове значення

# print ( solve_riddle ( riddle, word_length, start_letter, reverse ) ) # Принтимо результат роботи функції 



