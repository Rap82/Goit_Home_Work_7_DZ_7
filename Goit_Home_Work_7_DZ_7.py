# ===================  Home work 7 ========================

# =================== Створення та встановлення власних пакетів ==========================

# Модуль, що містить інструкції по установці, викликає функцію setup з пакету setuptools. 
# Функція setup робить установку пакету в системі і містить параметри, що конфігурують установку.

# Детальні інструкції по написанню setup.py ви можете отримати на сторінці документації.

# Приклад вмісту setup.py:

# from setuptools import setup

# setup(name='useful',
#       version='1',
#       description='Very useful code',
#       url='http://github.com/dummy_user/useful',
#       author='Flying Circus',
#       author_email='flyingcircus@example.com',
#       license='MIT',
#       packages=['useful'])
# В даному прикладі ми викликаємо setup з додатковими інформаційними параметрами, які будуть доступні користувачам. 
# А саме, ми вказали ім'я пакету, версію, короткий опис пакету, адресу, де можна подивитися початковий код, ім'я автора, 
# його email, ліцензію, набір пакетів, які включені у поставку.

# Що якщо наш пакет досить великий і прописувати вручну усі модулі packages незручно і існує ризик помилитися? 
# Тоді у setuptools є функція find_namespace_packages, яка допоможе знайти всі модулі і не пропустити нічого:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages()
# )
# Такий пакет можна опублікувати на PyPi і тоді його можна буде встановити за допомогою pip, 
# або опублікувати початковий код і тоді можна буде встановити з початкових кодів.

# Щоб встановити цей пакет з початкового коду, виконайте в консолі pip install . або pip install -e . у папці, де лежить setup.py


# ================================ Звдання 1 / Task 1 ======================================

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для ініціалізації свого проекту створіть допоміжну функцію do_setup(args_dict), яка буде викликати функцію setup з параметрами 
# зі словника args_dict.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }

# ++++++++++++++++++++++++++++++++++  Код /Code  +++++++++++++++++++++++++++++++++++++++++++++++++


# args_dict = {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# } # Тестовий словник який має структуру яка відповідає умовам завдання.


# def do_setup ( args_dict ) : # Функція *do_setup ( args_dict )- для виклику функції *setup ( **args_dict )
#                              # Приймає один аргумент  словник  *args_dict - вказаного формату . З параметрами цього словника буде виклки функції setup ( **args_dict )   
    
#     setup ( **args_dict )   # Функція яка приймає як аргументи значення з словника і співставляє їх по порядку з значеннями описаними в самій функції  def setup (...)- дивись опис функції в коді нижче.
#                             # Важливо : щоб в описі функції *def setup(...) , Було стільки аргумантів скільки в словнику ключів *args_dict ,
#                             # *setup ( **args_dict ) - такий запис рівноціний в ручну створеному запису   *setup (name = args_dict['name'] , version=args_dict['version'] , description=args_dict['description'], url=args_dict['url'], author=args_dict['author'], author_email=args_dict['author_email'],license=args_dict['license'] ,packages=args_dict['packages'] )
#                             # де перший аргумент *name переданий у функцію *setup() отримає значення взяте з нашого словника *args_dict за ключем *'name'
#                             # другий аргумент *version переданий у функцію *setup() отримає значення взяте з нашого словника *args_dict за ключем *'version'
#                             # і так далі. Щоб обійти явне задавання аргументів можна зробити запис **імя_зміної- де дві зірочки "**" - це означає всі значення . імя_зміної - це імя змінної що буде містити множину  значень (тип list, dict, set , tuple -та інші )
    
    


# # def setup ( **_ ) :  # Якщо кількість аргументів і їх імена ,які будуть передані ,наперед невідомо можна їх записати у вигляді  (**_ )
# #                      # Де '**'- множина значень .'_' - одинокий символ підкреслення - це в пайтон позначення будь якої зміної імя якої наперед невідомо.

# #     for elemet,value in _.items() :  # Ми можемо також працювати з наперед невизначеним аргументом якщо його тип буде відповідати тому що ми хочемо з ним зробити.
# #                                      # в нашому випадку *setup ( **args_dict ) . **args_dict- це множина типу словник . Тому ми можемо скористатись всіма методами і способами  які достіпні для роботи з словниками
# #                                      # В нашому випадку ми будемо в циклі for проходитись по всіх ключах і значеннях з невідомого наперед словника і принтити ключ і відповідне значення попорядку. 
# #         print (elemet)
# #         print (value)
    
    

# # # def setup (name , version , description , url, author, author_email, license, packages ) : # Функція  з наперед відомими аргументами. і явно оголошеними . Сформована тільки під цей конкретний випадок .
# #                                                                                              # def setup ( **_ ) : - такий запит є універсальний якщо наперед невідомом ні кількість значень ні назву зміної.

# #     #  print (name , version , description , url, author, author_email, license, packages )

    
# # do_setup (args_dict)  # виклик функції *do_setup (args_dict)


# ================================ Звдання 2 / Task 2 ======================================

# Якщо в нашому пакеті є залежності, щоб він запрацював, потрібно встановити додаткові пакети, треба їх всі прописати в параметрі install_requires:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages(),
#     install_requires=['markdown']
# )
# В цьому прикладі наш пакет буде вимагати встановити спочатку пакет markdown перед встановленням. 
# Порядок встановлення залежностей визначає сам менеджер пакетів (pip наприклад).


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Модифікуємо приклад попередньої задачі. Для функції do_setup необхідно передбачити другий параметр, який буде списком залежностей.

# Функція do_setup(args_dict, requires) повинна викликати функцію setup з параметрами зі словника args_dict та параметром install_requires,
# який набуває значення requires.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }

# ++++++++++++++++++++++++++++++++++  Код /Code  +++++++++++++++++++++++++++++++++++++++++++++++++

# from setuptools import setup # для VScode цей імпорт оки непотрібний. Видає зараз помилку мабудь неістальвана ця біліотека наразі в мене.

# args_dict = {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
#             }  # Тестовий словник який має структуру яка відповідає умовам завдання.

# def do_setup ( args_dict, requires ) :  # Функція *do_setup ( args_dict )- для виклику функції *setup ( **args_dict )
#                                     # Приймає Два аргумента, Перший словник *args_dict а інший  - значення *requires які тереба добавити в нашу функцію *septup(**args_dict ) для нового параметру *install_requires
#                                     # Дане питання закриваэмо ти що просто добавляэмо в наш словник *args_dict який передасться в функцію  do_setup(args_dict, requires) новий ключ *install_requires  і його значення *requires
#                                     # Добавляємо новий ключ і значення внаш словник методом *імя_словника.update({'ключ': *значення})

#     args_dict.update ( { 'install_requires': requires } ) # Метод .update({'key': value})- записує в наш словник нову пару ключ : значення в кінець словника.
#                                                           #  args_dict.update({'install_requires': requires}) - в нашому випадку до словника *args_dict в кінці добавить  ключ 'install_requires' з значенням *requires

#     setup ( **args_dict )  # Виклик функції *setup ( **args_dict ) 
   


# def setup ( **_ ) :  # Якщо кількість аргументів і їх імена ,які будуть передані ,наперед невідомо можна їх записати у вигляді  (**_ )
#                      # Де '**'- множина значень .'_' - одинокий символ підкреслення - це в пайтон позначення будь якої зміної імя якої наперед невідомо.

#     for elemet,value in _.items() :  # Ми можемо також працювати з наперед невизначеним аргументом якщо його тип буде відповідати тому що ми хочемо з ним зробити.
#                                      # в нашому випадку *setup ( **args_dict ) . **args_dict- це множина типу словник . Тому ми можемо скористатись всіма методами і способами  які достіпні для роботи з словниками
#                                      # В нашому випадку ми будемо в циклі for проходитись по всіх ключах і значеннях з невідомого наперед словника і принтити ключ і відповідне значення попорядку. 
#         print ( elemet )  # Принтанути поточний ключ з переданого в функцію словника
#         print ( value )   # # Принтанути відповідне  поточне значення з переданого в функцію словника . 
#                             # Принтане всіключі і всі їх значення попорядку . Ключ і відповідне значення бо прінтемо в циклі for де попорядку  перебераємо пари ключ і занчення 

# requires = "fine"  # занчення для перевірки.

# do_setup ( args_dict, requires ) # Виклик функції *do_setup ( args_dict, requires ) 

#  ++++++++++++++++++++++++++++++++++  Код /Code для атопереврки +++++++++++++++++++++++++++++++++++++++++++++++++

# def do_setup ( args_dict, requires ) : 

#     args_dict.update ( { 'install_requires': requires } ) 

#     setup ( **args_dict )



# ================================ Звдання 3 / Task 3 ======================================

# Якщо наш пакет містить додаток, який можна викликати з консолі, зручно буде додати можливість виклику цього застосування 
# у будь-якому місці нашої системи з консолі. Для цього у виклику setup додамо ще один параметр — entry_points. 
# Цей параметр приймає словник, де ми можемо вказати список "точок входу" для ключа console_scripts.

# Наприклад, в нашому пакеті у модулі some_code.py є функція hello_world, яка виводить у консоль повідомлення Hello World!. 
# Після встановлення пакету ми зможемо у будь-якому місці нашої системи виконати в консолі команду: helloworld і отримаємо у відповідь Hello World!.

# Щоб це працювало в системі Python повинен викликатися при виклику файлів з розширенням .py та setup.py має бути змінений:

# from setuptools import setup, find_namespace_packages

# setup(
#     name='useful',
#     version='1',
#     description='Very useful code',
#     url='http://github.com/dummy_user/useful',
#     author='Flying Circus',
#     author_email='flyingcircus@example.com',
#     license='MIT',
#     packages=find_namespace_packages(),
#     install_requires=['markdown'],
#     entry_points={'console_scripts': ['helloworld = useful.some_code:hello_world']}
# )
# У списку точок входу console_scripts можуть бути виконувані файли (.exe), скрипти Bash, cmd, PowerShell і будь-який інший файл,
# який операційна система зможе виконати.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Продовжуємо модифікувати приклад. Для функції do_setup необхідно передбачити третій параметр, який буде словником, 
# де ми можемо вказати список "точок входу" для ключа console_scripts.

# Функція do_setup(args_dict, requires, entry_points) повинна викликати функцію setup з параметрами словника args_dict 
# та параметром install_requires, який набуває значення requires. Третій параметр entry_points приймає словник, 
# де ми можемо вказати список "точок входу" для ключа console_scripts.

# Структура словника для параметра args_dicts має бути наступною

# {
#     "name": "useful",
#     "version": "1",
#     "description": "Very useful code",
#     "url": "http://github.com/dummy_user/useful",
#     "author": "Flying Circus",
#     "author_email": "flyingcircus@example.com",
#     "license": "MIT",
#     "packages": ["useful"],
# }


#  Алгоритм : вирішення просто обновляємо наш словник ще одним новою паролю ключ і значення відповідно до умови завдання.
# Завдання вчить як маючи почакткове сформоване значення для функції поповнювати новими аргументами за певним шаблоном.

#  ++++++++++++++++++++++++++++++++++  Код /Code для атопереврки +++++++++++++++++++++++++++++++++++++++++++++++++

# def do_setup ( args_dict, requires, entry_points ) :
#     args_dict.update ( { 'install_requires': requires } ) # записуємо в наш словник в кінці нову пар ключ і значення.
#     args_dict.update ( { 'entry_points': entry_points } ) # записуємо в наш словник в кінці нову пар ключ і значення.
#     setup ( **args_dict )  # Викликаєм функцію вже з оновленими аргументами і їх значеннями.


# ================================ Звдання 4 / Task 4 ======================================

# Далі підуть завдання на повторення та закріплення матеріалу. Можна використовувати будь-які техніки, з якими ви зіткнулися у процесі навчання. 
# І почнемо ми з функцій.

# Визначення функції починається з ключового слова def, після повинно йти ім'я функції, далі дужка (, потім дужка, що закриває ) 
# і знак двокрапки :. Тіло функції починається з нового рядка з необхідним відступом. Python вважає, що знайшов кінець тіла функції, 
# як тільки відступ у рядку стане такого ж рівня, як в оператора def.

# Тільки визначення функції не змусить код виконатись, необхідно виконати виклик функції.

# def hello():
#     print('Hello user!')


# hello()  # Hello user!
# Велику гнучкість функцій надає той факт, що вони можуть приймати аргументи через передачу їм значень у круглих дужках. 

# При виклику функції значення цих аргументів ініціалізують змінні параметрів. Параметри прописуються в круглих дужках під час оголошення функції. 
# Кількість параметрів визначає кількість аргументів, які передаються під час виклику функції.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# У Python існує рядкова функція isdigit(). Ця функція повертає True, якщо всі символи в рядку є цифрами, і є принаймні один символ, інакше — False.
# Напишіть функцію з ім'ям is_integer, яка розширюватиме функціональність isdigit(). 
# При перевірці рядка необхідно ігнорувати початкові та кінцеві прогалини в рядку.
# Після виключення зайвих прогалин рядок вважається таким, що представляє ціле число, якщо:

# її довжина більша або дорівнює одному символу
# вона повністю складається з цифр
# передбачити виняток, що, можливо, є початковий знак "+" або "-", після якого мають йти цифри

#  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# def is_integer( s ): # Функція приймає рядок (тип *str) видаляє всі пробіли з переді і з кінця рядка . Видаляє занк + або - на початку рядка 
    
#     s = s.strip ()  # Видаляємо всі пробіли на початку і в кінці рядка і овлений рядок перезаписуємо в наш рядок *s . Метод *імя_рядка.strip ()- без аргумету ,видаляє з нашого рядка (*імя_рядка) всі символи пробілів з почактку і з кінця .
#                     # Перевіряє чи є смиволи пробілів напочатку і в кінці рядка і видалє їх якщо вони є повертає рядок очищений від них. якщо немає ні напочатку ні накінці поверта назад незмінений рядок. Якщо пробіли зустрічаються в середені рядка то їх не видалє.
    
#     s = s.lstrip ("+") # Після того як позбулись пробілів видалємо символ "+" з початку рядка . Метод *.lstrip ("+") видалє всі символи які вказані як параметр  які йдуть підряд один за одним без пропусків. Якщо параметр невказаний *.lstrip ()- видалє всі пробіли напочатку рядка.
#     s = s.lstrip ("-") # # Після того як позбулись можлививх пробілів і можливого символа "+" з початку рядка . Видалємо можлививй симивол "-" тим самим методом тільки з парметром "-".  *.lstrip ("-")
   
#     if len(s) == 0:    # Перевірємо чи після наших змін в рядку *s -ще залишились якісь символи . Якщо рядок пустий . Значить повертає *False
#                        # якщо умова невиконається з начить в рядку ще залишились символи. Дальше вкоді перевіримо чи ті символи це тільки цифри.
       
#        return False    # Повертаємо з фнкції  is_integer( s ) - значення *False 
    
#     return s.isdigit() # Вже відформатований наш рядок *s  без пробілів на початку і в кінці , і без можлививх символів на початку + чи - Перевіряємо методом 

# s = "  +32  " # True # Тестові значення
# s = "32  " # True  # Тестові значення
# s = "32  3" # False # Тестові значення ( є пробіли в середені рядка.)
# s = "-+35" # False # Тестові значення ( в нашому випадку спочатку видалє + напочатку рядка а вцьому випадку рядок починаться з мінуса тому його не видалить і в рядку залишаться не цифри)
# s = "++-45" #True (за умовою має бути або "+"" або "-" і за одним із зних відразу   цифри,  для такого запису малоб повернути False про те повертає True але для автоперевіки підішло.Мабуть вних немає такого тестовго значення.))))

# print ( is_integer ( s ) ) # Притимо значення яке поверне функції *is_integer ( s )


# ================================ Звдання 5 / Task 5 ======================================


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Дуже часто люди у своїх повідомленнях не ставлять великі літери, особливо це стало масовим явищем в еру мобільних. пристроїв. 
# Розробіть функцію capital_text, яка прийматиме на вхід рядок з текстом і повертатиме рядок з відновленими великими літерами.

# Функція повинна:

# зробити великою першу літеру в рядку, попри прогалини
# зробити великою першу літеру після точки, попри прогалини
# зробити великою першу літеру після знака оклику, попри прогалини
# зробити великою першу літеру після знака питання, попри прогалини

#  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# def first_big_leter_split_point ( s ) : # Функція приймає один аргумент рядок і повертає новий  рядок . Де речення починається з великої букви  ігнорує всі пробіли на початку речення .
#                                         # Речення в рядку розділені крапкою . Фунція перевіряє всі речення які розділені карпкою в рядку і робить перше слово в речені з великої букви всі інші символи залишає без змін.


#     list_new_elem = []       # Список в який будемо збирати змінені речення для подальшого їх обєнання в рядок. Для поверненя з функції . Початкове значення пустий .
#     list_s = s.split ( '.' )  # Метод .slpit() приймає один аргумент . За цим аргумантом розбиває рядок і повертає список рядків розбитих за вказаним символом без символу по якому розбиває.
#                               # Для нашого зназення s поверне наступний список *ist_s = ['  віра  гуляла в саду ', ' по дорозі її зустрівся  знайомий хлопчик  ', '   привіт ! - сказала Віра ', ' як тебе звати ? петро -відповів хлопчик    ', '']
#     #print (list_s)
#     for  element in list_s : # В циклі проодимось по лементах списку . Де елементи будуть рядкі які утворилися після розділення по крапці.
       
#        space = " "  # space = знаку пробілу " "  Потрібний для відновлення початкового рядка якщо він починається з пробілів.
#        count = 0    # лічильник . Початкове значення 0 . Використаємо для підрахунку пробілів на початку кожного речення яке розділене Крапкою "."

#        for symvol in element : # Вкладений цикл. Проходимось по кожному символу з нашого рядка з утвореного списку після розділення методом  s.split ( '.' ) 
#            new_string = ""     # Рядок в який будемо записувати змінений рядок Вже звеликою першою буквою на початку рядка.
           
#            if symvol == " " :  # Перевірка чи перші символи рядка є пробілами . Якщо є ряхуємо скільки їх щоб в зміненому рядку їх дабавити на початку як і в оригінальному було.
               
#                count += 1      # Збільшує наш лічильник на 1 стільки раз скільки буде пробілів на початку речення. 
#                continue        # Оператор *continue ігнорує весь код нижче за себе поки спрацьовує умова if / . і повертає цик на наступну ітерацію.
           
#            #print(count)
        
#            new_elemet = element.lstrip()  # Видаляємо на початку поточного рядка всі пробіли . Вони вже ванс пораховані в *count і поки непотрібні.

#            list_new_element = new_elemet.split() # Розбиваємо наше речення яка вже починається з букви на окремі слова за знаком пробіл - " ".
           
#            list_new_element[0] = list_new_element[0].capitalize() # Перший елемент списку і буде наша перше слово в речені де потрібно зробити першу букву великою . Застосовуємо метод .capitalize() - робить першу літеру в рядку великою все інше перетворює в меланькі букви.
           
#            new_elem = " ".join ( list_new_element )   # Після того як порахували пробіли і зробили першу букву Великолою в першому слові речення склеюємо наш рядок назад функцією " ".join ( list_new_element ) де " " - символ пробілу  по якому склеюємо слова з списку *list_new_element .
#                                                        # Символ по якому склеює метод *str.join ( *list ) незаписується перед першим значенням з списку і після останього значення з списку. За потреби їх треба додавати окремо.

#            new_elem = space*count + new_elem  # Добавляємо спереді до нашого склеєного ряда ту кількість символів з зміної  *space яку нарахували в *count  щоб рядок був аналогічним орігінальному тільки вже з великою першою буквою впершому слові з  речень  розідених крапкою.
#            #print ( new_elem )
#            list_new_elem.append ( new_elem ) # Добавляємо всі речення в наш список з якого потім сформуємо рядок схожий на початковий тільки з великим першими літерами на пояатку кожного речення яке розділено крапкю.

#            break # Перериваємо вкладений цикл. Перебирати всі символи з речення немає змісту . все що треба ми виконали .
    
    
#     #print (list_new_elem)
#     new_string = ' .'.join ( list_new_elem )  # Після того як в циклі зібрали всеь список з наших речень з заміненими перших бук в словах на початку речення на великі . склеюємо нашіречення в оди рядок по символи яким їх розділяли.
#                                              #  В нашому випадку це було по крапці . Утворюємо початковий рядок переданий у функцію але вже з великими першими буквами в словах на початку кожного речення розділеного крапко.    return new_string
#     return new_string     # повертаємо з функції змінений рядок.
#     #print (new_string)

# def first_big_leter_split_question_mark ( s ) : # Функція робить все те саме що і first_big_leter_split_point ( s ) тільки розділяє і склеює пілся заміни на велику першої букви в першому слові на початку кожного речення по символу знак питання '?' .

#     list_new_elem = []
#     list_s = s.split ( '?' )
    
#     for  element in list_s :
#        space = " "
#        count = 0 

#        for symvol in element :
#            new_string = ""
           
#            if symvol == " " :
               
#                count += 1
#                continue
           
#            #print(count)
        
#            new_elemet = element.lstrip()

#            list_new_element = new_elemet.split()
           
#            list_new_element[0] = list_new_element[0].capitalize()
           
#            new_elem = " ".join ( list_new_element )

#            new_elem = space*count + new_elem
#            #print ( new_elem )
#            list_new_elem.append ( new_elem )
#            break
    
    
#     #print (list_new_elem)
#     new_string = ' ?'.join ( list_new_elem )
#     return new_string

# def first_big_leter_split_exclamation_mark ( s ) :  # Функція робить все те саме що і first_big_leter_split_point ( s ) тільки розділяє і склеює пілся заміни на велику першої букви в першому слові на початку кожного речення по символу знак питання '!' .

#     list_new_elem = []
#     list_s = s.split ( '!' )
    
#     for  element in list_s :
#        space = " "
#        count = 0 

#        for symvol in element :
#            new_string = ""
           
#            if symvol == " " :
               
#                count += 1
#                continue
           
#            #print(count)
        
#            new_elemet = element.lstrip()

#            list_new_element = new_elemet.split()
           
#            list_new_element[0] = list_new_element[0].capitalize()
           
#            new_elem = " ".join ( list_new_element )

#            new_elem = space*count + new_elem
#            #print ( new_elem )
#            list_new_elem.append ( new_elem )
#            break
    
    
#     #print (list_new_elem)
#     new_string = ' !'.join ( list_new_elem )
#     return new_string
       
                   
            
# def capital_text (s) : # jосновна фінкція . Приймає рядок в якому потрібно виконати всі зміни згідно умови завдання . І повернути змінений рядок за 3 критерями.
   
#     new_string = first_big_leter_split_point ( s ) # Опрацьовуємо отримани з функції *capital_text (s) вхідний рядок . Робимо відповідні зміни і повертаємо його назад. Зміни відбуваються в рядку по значеню крапка.

#     new_string = first_big_leter_split_question_mark ( new_string ) # Повернутий  з функції *first_big_leter_split_point ( s ) новий рядок опрацювуємо функцією *first_big_leter_split_question_mark ( new_string ) - змінений за символом "." новий рядок повертаємо 

#     new_string = first_big_leter_split_exclamation_mark ( new_string ) # Повернутуй з функції *first_big_leter_split_exclamation_mark ( new_string ) новий рядок опрацювуємо функцією first_big_leter_split_question_mark ( new_string ) - змінений за символом "!" новий рядок повертаємо 

#     new_string = new_string + " " + s[-1]  # Добавляємо до нашого зміненого рядка останій пробіл і останй символ з орігінального рядка щоб його невтрати.  де *s[-1]  останій символ орігінального рядка переданого в змінуоскільки в процесі роботи методу .join(*list) ми його втратимо.
    
#     return new_string # повертаємо змінений рядок зідно завдання.

             
  

# s = '  віра  гуляла в саду . по дорозі її зустрівся  знайомий хлопчик  .   привіт ! - сказала Віра . як тебе звати ? петро -відповів хлопчик    .' # Рядок запропонований для змін. Тестове значення.



# print ( capital_text (s) ) # Виклик фінкції *capital_text (s)

# # print ( first_big_leter_split_point ( s ) )
# # print (first_big_leter_split_question_mark ( s ))
# # print (first_big_leter_split_exclamation_mark ( s ))


# ================================ Звдання 6 / Task 6 ======================================

# Давайте повторимо теорію щодо зрізів у списків.

# Для впорядкованих контейнерів існує особливий синтаксис, щоб отримувати деякі послідовності елементів з контейнера.

# Наприклад, необхідно отримати перші 5 букв рядка:

# greeting = "Hello my little friend"
# hello = greeting[0:5]
# Змінна hello у цьому прикладі міститиме рядок 'Hello'.

# Синтаксис зрізу складається з трьох чисел, вказаних через двокрапку. 
# Перше число — це індекс першого елемента, який треба взяти для зрізу. 
# Друге число — це індекс, до якого (не включаючи його) брати елементи для нової послідовності. 
# І третє, воно за замовчуванням дорівнює одиниці, — це крок, з яким треба брати елементи у нову послідовність.

# Візьмімо список чисел від 1 до 10 і збережемо окремо парні, непарні та кратні 3.

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[0:9:2]
# even_numbers = numbers[1:9:2]
# three_numbers = numbers[2:9:3]
# odd_numbers — ми беремо числа, починаючи з індексу 0 до 9 з кроком у 2 (отримаємо [1, 3, 5, 7, 9])
# even_numbers — ми беремо числа, починаючи з індексу 1 до 9 з кроком у 2 (отримаємо [2, 4, 6, 8])
# three_numbers — ми беремо числа, починаючи з індексу 2 до 9 з кроком у 3 (отримаємо [3, 6, 9])
# Ви можете не вказувати початковий, кінцевий індекс чи крок, пропускаючи його. 
# За замовчуванням Python візьме зріз від початку до останнього елемента з кроком 1.

# Перепишемо попередній приклад у скороченому синтаксисі:

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[::2]
# even_numbers = numbers[1::2]
# three_numbers = numbers[2:9:3]

# numbers_copy = numbers[:]
# numbers_copy у цьому прикладі — це зріз, який бере всі елементи numbers від початку до кінця з кроком 1.

# Увага
# Важливо пам'ятати, що до зрізу не входить елемент з індексом, до якого треба брати елементи.

# numbers = [0, 1, 2, 3]
# first_three = numbers[0:3]  # [0, 1, 2]
# У цьому прикладі елемент 3 з індексом 3 не увійде до first_three.

# Цікаво
# Отримати список `numbers` у зворотному порядку допоможе `numbers[::-1]`

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Всі ви, можливо, стикалися з ребусами "Знайди слово". Вони існують як текстові варіанти, 
# так і як програми для мобільних додатків. Нагадаємо коротко суть ребуса. 
# У великому квадраті з набором букв необхідно знайти слово по горизонталі та інколи по вертикалі.

# game
# Реалізуйте функцію solve_riddle(riddle, word_length, start_letter, reverse=False) для знаходження слова, що шукається в рядку ребуса.

# Параметри функції:

# riddle - рядок із зашифрованим словом.
# word_length – довжина зашифрованого слова.
# start_letter - літера, з якої починається слово (мається на увазі, що до початку слова літера не зустрічається в рядку).
# reverse - вказує, у якому порядку записане слово. За замовчуванням — в прямому. Для значення True слово зашифроване 
# у зворотньому порядку, наприклад, у рядку 'mi1rewopret' зашифроване слово 'power'.
# Функція повинна повертати перше знайдене слово. Якщо слово не знайдене, повернути пустий рядок.

# Коментар  : Зашифрованим словом буде вважатиьсь будь який набір символів починаючи з символа start_letter і наступні за ним попорядку  (word_length - 1) .
#  або вправо від нього або вліво віднього в залежності від значення *reverse  . *True - формуємо слово з символів попорядку з права на ліво . False - з ліва на право .
# Слово буде важатись вірним якщо воно буде починатись з start_letter і містити сумарно word_length символів записаних в послідовність символів згідно умови.

##  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++



# def solve_riddle ( riddle, word_length, start_letter, reverse = False ) : # Функція яка  перевіряє чи є врядку *riddle символ *start_letter
#                                                                           # Якщо немає то відразу повертає пустий рядок *""
#                                                                           # Якщо є робить додаткову перевірку згідно вимог завдання .
#                                                                           # Якщо перевіркка відбувається успішно повертає слово яке відповідає критеріям пошуку вказаних в завдані .
#                                                                           # Читай коментар в (Умова / Condition )

#     latter_index = riddle.find ( start_letter )   #  Перевіряємо наш рядок  *riddle чи є в ньому *start_letter Методом *імя_рядка.find (*str, *[start],*[end])
#                                                   # Метод S.find (str, [start],[end]) повертає індек перешго найденого від початку рядка *символа/символів які шукаємо в рядку якщо такі найдуться .
#                                                   # Якщо такого  *символа/символів ненайде повертає *-1 .Може містити необовязкові параметри *[start] і *[end] 
#                                                   #  Де *[start] вказує на індекс смивола з рядка з якого почати пошук а *[end] на якому закінчити . Якщо їх невказувати то пошук проводиться по всьому рядку з початку в кінець посимвольно 
#                                                   #  Як тільки буде знайдено перший збіг ,метод поверне індекс знайденого символа з даного рядка чи його частини (якщо вказано параметри *[start] і *[end])       

#     print ( latter_index )

#     if latter_index >= 0 :                         # Умова основної переврки . Якщо latter_index = -1 значить Метод *riddle.find ( start_letter ) - не найшов жодного входження *start_letter в рядку *riddle 
#                                                    # Умова не виконається перйде на останій *else і повернем пустий рядок "" з функції  *solve_riddle ( riddle, word_length, start_letter, reverse = False )
#                                                    # Якщо *latter_index ,>= 0 Значить збіг знайшовся перевірємо чи виконаються інші умови завдання.
#         if reverse == False :                      # Умова якщо *reverse == False  значить шікаємо наше слово від start_letter і на довжину *word_length-1 з ліва на право.   

#             encode_word = riddle [ latter_index : latter_index + word_length ] # *encode_word - слово яке шукаємо . Наше слово це буде зріз з рядка *riddle [ latter_index : latter_index + word_length ] 
#                                                                                # де *riddle рядок з якого робимо зріз 
#                                                                                # *latter_index - символа *start_letter 
#                                                                                # *latter_index + word_length - до індекса символая який найшли добавляжмо довжену слова що шукаємо. 
            
#             if len ( encode_word ) == word_length :   # Перевіряємо чи слово що утворилось в результаті зрізу буде мати відповідну довжину .Якщо так то це є наше слово його і повртаємо. 
#                                                       # Якщо ні значить наше слово невірне повертаємо пустий рядок.   

#                 return encode_word                    # повертаємо наше слово яке відповідає умаві завдання  
            
#             else : 

#                 print ('пустий рядок ')

#                 return ""                            # повертаємо пустий рядок.Якщо умова *if len ( encode_word ) == word_length : - не виконалась

        
#         else :   # Якщо умова *if reverse == False : не виконалась. значить *reverse == True і пошук слова має відбутись з права на ліво від *start_letter 

#             encode_word = riddle[ latter_index  : latter_index - word_length :  -1] # Робимо перевернутий зріз 
            
            
#             if len ( encode_word ) == word_length :  # Перевіряємо чи слово що утворилось в результаті зрізу буде мати відповідну довжину .Якщо так то це є наше слово його і повртаємо. 

#                 return encode_word                   # повертаємо наше слово яке відповідає умаві завдання 
            
#             else :

#                 print('пустий рядок ')

#                 return ""                             # повертаємо пустий рядок.Якщо умова *if len ( encode_word ) == word_length : - не виконалась
#     else :
#         print('пустий рядок ')

#         return ""


# riddle = 'mi1rewopret'   # Тестове значення

# # riddle = 'mi1reworettttt' # Тестове значення

# word_length = 5 # Тестове значення

# start_letter = "p"   # Тестове значення
# # reverse = True       # Тестове значення
# reverse = False      # Тестове значення

# print ( solve_riddle ( riddle, word_length, start_letter, reverse ) ) # Принтимо результат роботи функції 


# ================================ Звдання 7 / Task 7 ======================================

# Давайте повторимо методи списків

# Додавання елементу в кінець списку: my_list.append(element)

# chars = ['a', 'b']
# chars.append('c')
# print(chars)  # ['a', 'b', 'c']
# видалення елементу зі списку викличе помилку, якщо такого елементу немає в списку: my_list.remove(element)

# chars = ['a', 'b']
# chars.remove('b')
# print(chars)  # ['a']
# Повернути i-ий елемент та видалити його зі списку i_element = my_list.pop(i). За замовчуванням i = -1

# chars = ['a', 'b']
# last = chars.pop(1)
# print(chars)  # ['a']
# print(last)  # 'b'
# Розширити список a_list елементами із b_list: a_list.extend(b_list)

# chars = ['a', 'b']
# numbers = [1, 2]

# chars.extend(numbers)
# print(chars)  # ['a', 'b', 1, 2]
# Вставити x на позицію з індексом i: my_list.insert(i, x)

# chars = ["a", "b"]
# chars.insert(1, "c")
# print(chars)  # ['a', 'c', 'b']
# Очистити список: my_list.clear()

# chars = ['a', 'b']
# last =  chars.clear() print(chars) # []
# Знайти індекс першого елемента у списку рівного x: index = my_list.index(x)

# chars = ['a', 'b', 'c', 'd']
# c_ind = chars.index('c') print(c_ind) # 2
# Повернути кількість елементів у списку рівних x: x_number = my_list.count(x)

# chars = ['a', 'b', 'c', 'a']
# a_count = chars.count('a')
# print(a_count) # 2
# Відсортувати список за зростанням: my_list.sort(key=None, reverse=False)

# chars = ['z', 'a', 'b']
# chars.sort()
# print(chars) # ['a', 'b', 'z']
# Змінити порядок елементів у списку на зворотний: my_list.reverse()

# chars = ['a', 'b']
# chars.reverse()
# print(chars) # ['b', 'a']
# Повернути копію списку: copy_of_my_list = my_list.copy()

# chars =  ['a', 'b']
# chars_copy = chars.copy()
# chars == chars_copy # True


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У четвертому модулі розв'язували завдання нормалізації даних. Розширимо її.

# При аналізі даних часто виникає необхідність позбавитися екстремальних значень, перш ніж почати працювати з даними далі. 
# Напишіть функцію data_preparation, яка приймає набір даних, список списків (Приклад: [[1,2,3],[3,4], [5,6]]).

# Функція повинна видаляти з переданих списків найбільше і найменше значення, але якщо розмір списку понад два елементи. 
# Після видалення даних з кожного списку необхідно злити їх разом в один список, 
# відсортувати його за зменшенням та повернути отриманий список як результат 
# (Для прикладу вище результат буде наступним: [6, 5, 4, 3, 2]).

##  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# def format_list_no_bigest_no_smallest ( list_data ) : #  Допоміжна функція . Приймає один аргумент список тип *list 
#                                                       #  Повртає список з якого прибрано найменше і найбільше значення .
#                                                       #  Якщо список складається з двох і менше елементів повератє список без змін    
#     result_list = []                                 #  Список в який будемо формувати наші значення згідно умови завдання

#     if  len ( list_data ) > 2  :                     # Перевіряємо чи довжина нашого списку більша за 2 . Тобто список містить 3 і більше елементів.
#                                                      # Якщо умова   *if  len ( list_data ) > 2 виконалась значить опрацьовуємо список і приводимо до потрібного вигляду який відповідає умові завдання. 
#         min_in_list = min ( list_data )              # *min_in_list - присвоємо значення найменшого елнмента з списку . використаємо вбудовану функцію min(*list) приймає список і повертає найменший елемент з списку
#         max_in_list = max ( list_data )              # *mix_in_list - присвоємо значення найбільшого елнмента з списку . використаємо вбудовану функцію mix(*list) приймає список і повертає найбільший елемент з списку
        
#         for element in list_data :                   # Цикл в якому будемо перебирати елементи з списку . Перевіряємо чи елемент з списку не дорівнює мінімальному і максимальному значенню визначенному за допомогою min(*list) і max(*list)
#                                                      # Формуємо наш список *result_list з всіх елементів вхідного списку без найменшого і найбільшого значення.  
           
#            if element != min_in_list and element != max_in_list :  # Перевірка чи невідповідає поточний елемент найменшому і найбільшому значеню. Якщо умова виконується то добавляємо поточний елемент до списку *result_list
               
#                #print (element)
#                result_list.append ( element )        # Добавляємо поточне значення до списку методом *імя_списку.append ( *значення_яке добавляємо_в список )
#                                                      # *result_list.append ( element ) - в наш список *result_list добавляємо в кінець почточний *element 
          
#         return result_list                           #  Повертаємо сформований список без найменшогоі найбільшого значення.
  

#     else :

#         return list_data                            #  Повератємо список без змін якщо не виконалась умова if  len ( list_data ) > 2  : Тобто список складається з двох і менше елементів.




# def data_preparation ( list_data ) :      #  Основна функція в яка приймає список списків . Через фінкцію format_list_no_bigest_no_smallest ( element ) видаляє найбільше і найменше значення з кожного списку із списку списків.
#                                           # і повертає відформатований згідно умови завдання  список . 

#     result_list = []      #  #  Список в який будемо формувати всі наші значення з всіх списків які отримала функція  згідно умови завдання


#     for element in list_data :      # Цикл в якому будемо перебирати всі наші списки які місятяться  в основному списку *list_data . 
        
#         element = format_list_no_bigest_no_smallest ( element )    # Нормалізуємо поточний список з циклу  за допомогою функції   *format_list_no_bigest_no_smallest ( element ) 
        
#         print ( element )

#         for elm in element :             # Вбудований цикл в якому вже проходився по елементам нормалізованого поточного списку і кожен його елемент добавлаємо в основиний список *result_list.
            
#             result_list.append ( elm )       # Добавляємо поточний елемент з поточного списку в основиний список *result_list за допомогою методу *імя.append ( *значення )
            
#     result_list.sort ( reverse = True )     # Сформований в кінці всіх циклів список *result_list сортуємо в порядку спадання (від найбільшого до найменшого ) за допомогою методу *імя_списку.sort ( reverse = True )
#                                             # Де *result_list - список який сортуємо. *.sort ( reverse = True ) - метод сортування . *reverse = True -  парметер за яким сортувати . Якщо True це означає що сортувати від набільшого до найменшого. 
#                                             # Якщо параметер *reverse = False То сортує від набільшого до наменшого значення. Якщо параметер *reverse невказано то це False .Тобто позамовчуванню *імя_списку.sort () сортуєм від наменшого до набільшого 
#     # print(resalt_list)        #
#     return result_list          # Повертаємо з функції нормалізований і відсортований згідно умов завдання список .


        
        
    




# list_data = [[1,2,3],[3,4], [5,6]]   # Тестове значення
    
# # list_data = [1,2,3,3,4,5,6]   # Тестове значення

# # list_data = list_data = [1,2]  # Тестове значення

# print ( format_list_no_bigest_no_smallest ( list_data ) )   # Принтимо занчення роботи допоміжної функції  *format_list_no_bigest_no_smallest (list_data)  

# print ( data_preparation ( list_data ) )    #  Принтимо занчення роботи основної функції  *data_preparation ( list_data ) 


# ================================ Звдання 8 / Task 8 ======================================

# Перетворення рядка *str в список *list заданого формату.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Підсумкове завдання модуля два було на обчислення арифметичного виразу. У задачі на повторення ми підемо трохи іншим шляхом і 
# виконаємо схоже завдання, 
# одночасно закріпивши знання роботи зі рядками та списками. Розбиття рядка на лексеми є процес перетворення вихідного рядка в список з підрядків,
# званих лексемами (token).

# В арифметичному виразі лексемами є: оператори, числа та дужки. Операторами у нас будуть такі символи: *, /, - та +. 
# Оператори та дужки легко виділити у рядку — вони складаються з одного символу і ніколи не є частиною інших лексем. 
# Числа виділити складніше, оскільки ці лексеми можуть складатися з кількох символів. 
# Тому будь-яка безперервна послідовність цифр — це одна числова лексема.

# Напишіть функцію, яка приймає параметр рядок, що містить математичний вираз, і перетворює його в список лексем. 
# Кожна лексема має бути або оператором, або числом, або дужкою.

# Приклад:

# "2+ 34-5 * 3" => ['2', '+', '34', '-', '5', '*', '3']
# З метою спрощення вважаємо, що числа можуть бути тільки цілими, і вхідний рядок завжди міститиме математичний вираз, що складається з дужок, 
# чисел та операторів.

# Зверніть увагу, що лексеми можуть відокремлюватися один від одного різною кількістю прогалин, а можуть і не відокремлюватися зовсім. 
# Прогалини не є лексемами та до підсумкового списку потрапити не повинні.

##  ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++

# def token_parser ( s ) : # Функція буде приймати один аргумент це рядок в якому записаний матиматичний вираз в якому можуть міститись цілі числа , 
#                         # матиматичні знаки '(', ')', '+', '-', '*', '/' і будь яка кількість пробілів . Вираз записаний матиматично вірно . Тобто йде число а тоді матиматичний знак і знову числоі так далі. 
#                         # Числа і знаки можуть бути розділені будь якою кількістю пробілів , а можуть не розділятись пробілами. Числа між собою пробілами не розділяються. Тобто (2 5) -такий запис не добускається 
#                         #  Повертаємо список в якому кожен елемент є числом або ж матиматичним знаком (без пробілів) записаних в тій послідовності як вони зустрічаються у виразі.

#     LIST_NUMBERS = ['0', '1', '2', '3', '4','5', '6', '7','8', '9'] # Константа . Список який містить всі цифри від 0 до 9 .
    
#     num = ""                             # В зміну *num будемо записувати числа які зустрінуться в виразі по циферно.
#     list_arithmetic_expression = []      # Список який будемо повертати з функції . Буде містити всі числа і всі математичні знаки з виразу переданого у функцію.
#     list_expression = []                 # Проміжний список який буде крім чисел і матиматичних знаків мітити щей порожні рядки . *''
    
#     s = s + " "                          # Добавляємо в наш переданий рядок в кінці знак пробілу *" " щоб правильно відпрацювала логіка коду. Якщо вираз переданий у функцію закінчується цифрою а не пробілом то цю цифру небуде додано до списка . Щоб цього уникнути добавляємо обовязково в кінці пробіл.
#                                          # В процесі виконання коду всі пробіли будуть прибрані. 

#     for element in s :                  # В циклі перебираємо всі символи з рядка і перевіряємо що це . Якщо цифра то записуємо  її в *num поки зустрінеться не цифра. 
#                                         # тоді в *num -буде потрібне нам число , його добавлємо в проміжний список *list_expression , і очищаємо після того, присвоючи *num пустий рядок "" для запису нового числа.
#                                         # Якщо пробіл то пропускаємо його , він нам непотрібний , якщо матиматичний знак то добавлємо його в  *list_expression .
       
#         # print( element )

#         if element in LIST_NUMBERS :    #  Перевіряємо чи поточний елемент з циклу є цивфорою операторм *in Якщо поточний елемент є в нашому списку поверне True тоді умаова виконаєтьс . 
#                                         #  Значить поточний символ є цифрою . Добавлємо його в *num
            
#             num += f"{element}"         # Добавляємо в *num - тип*str - цифру . Якщо цифр буде кілька підряд утворить число записане в рядок тип *str . Запис робимо дописуючи в рядок до попередньої цифру наступну з циклу і так поки не зустріниться пробіл або ж матиматичний знак.
#             # print (num)
#         else :

#             list_expression.append ( num )  # Якщо поточний символ не цифра ТО значить наше число сформоване . Додаємо його в проміжний список *list_expression
            
#             num = ''                        # Очищаємо наше значення *num = '' присвоючи пустий рядок.
            
#             if element == " " :             # Перевіряємо чи поточний елемент є пробілом. Якщо пробіл то відразу берем наступний символ з рядка в циклі 
                
#                 continue                    # Оператор який пропускає весь код що є нижче нього і цикл переходить на наступну ітерацію.

#             else :                          # Якщо поточний елемент не є ні цифрою ні пробілом то це матиматичний знак . Оскільки за умовою в виразі може бути тільки числа , пробіли і матиматичні знаки.

#                 list_expression.append ( element )  # Добавляємо в наш список *list_expression матиматичний знак. Оскільки кожен раз коли в нас буде не цифра то в список *list_expression буде потряпляти пустий рядок то в кінці поточного циклу внас в проміжному списку будуть числа , пксті рядки та матиматичні знаки.
         
#     # print (list_expression)
   
#     for elm in list_expression :                # Цикл в якому будемо проходитись по проміжному циклу і видаляти пусті рядки .Добавляючи в основний список *list_arithmetic_expression тільки числа та математичні знаки.
            
#             if elm != '' :                      #  Перевіряємо чи поточний елемент з списку *list_expression не дорівнює пустому рядку.
#                                                 #  Якщо умова виконується добавляємо поточний елемент  *elm в наш кінцевий список list_arithmetic_expression 
#                                                 #  Якщо не виконується то це пустий рядок з ним нічого не робимо цикл перейде на наступну ітерацію.

#                 list_arithmetic_expression.append ( elm )  # Список який будемо повертати. Буде містити тільки числа і математичні знаки записані в тій послідовності як вони зустрічаються в виразі переданому у функцію.
    
#     return list_arithmetic_expression                      # Повертаємо з функції наш список. *list_arithmetic_expression 
   



# s = "2+ 34-57 * (36- 57)"  # Тестовий вираз 

# print ( token_parser ( s ) ) # Принтимо значення роботи функції .
#                              # Для нашого тесту *s = "2+ 34-57 * (36- 57)"  
#                              # виведе - ['2', '+', '34', '-', '57', '*', '(', '36', '-', '57', ')']


# ================================ Звдання 9 / Task 9 ======================================

#                                 Робота з підсписками.(sublist)

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Підсписком (sublist) називають список, що є складовою більшого списку. Підсписок може містити один елемент, множину елементів або бути порожнім.

# Наприклад, [1], [2], [3] та [4] є підсписками списку [1, 2, 3, 4]. Список [2, 3] також входить до складу [1, 2, 3, 4], 
# але при цьому список [2, 4] не є підсписком [1, 2, 3, 4], оскільки у вихідному списку числа 2 і 4 не є сусідами.

# Порожній список є підсписком будь-якого списку.

# Напишіть функцію all_sub_lists, що повертає список, який містить всі можливі підсписки заданого.

# Наприклад, якщо функції передано аргумент список [1, 2, 3], то функція має повернути наступний 
# список: [[], [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]].

# Функція all_sub_lists повинна повертати щонайменше один список з порожнім підсписком [[]].


##  ++++++++++++++++++++++++++++++++++  Код /Code для Автоперевірки +++++++++++++++++++++++++++++++++++++++++++++++++

# Коментар даний код не є універсальним і працює тільки для списку який складається з небільше ніж чотриньох елементів.
#  Цього достатньо щоб пройти автопереврку .
#  Повернутись коли буде більше часу і допрацювати можливо через рекурсивну функцію.

# def all_sub_lists ( data:list ) :  # Функція яка приймає один аргумент . це список . Далі формує новий список який складається з підсписків , які утворюються всіма можливими кобінаціями з елементів списку і повертає його . Порядок елементів в можливих комбінаціях змінювати непотрібно.
#                                    # Якщо переданий в функцію список є порожнім . Повертає список який містить порожній список *[[]].
#                                    # Функція має обмеження вхідний список має бути небільше 4 елементів. Інакше працює некоректно.
#                                    # *data:list - анотація зміної. На сам код впливу немає.Дозволяє наперед оголосити тип зміної
#                                    # щоб середовище VScode ,PyChar чи інше , могло видавати підсказки по методам які можна застосувати до зміної 
#                                    # тип якої оголошений через анотацію *імя_зміної : *тип(str , dict, list, int може бути будь який тип який є в python)

#     list_all_sublist = []          # Список в який будемо добавляти всі підсписки які задовільняють умову завдання і його будемо повертати в кінці.
    
#     if data == [] :                # Перевіряємо чи аргумент переданий у фінкцію пустий список . *data = [] .
#                                    #  Якщо так повертаємо список з порожнім списком . 
                                   
#         list_all_sublist.append ( [] )   # Додаємо в *list_all_sublist - прожній підсписок .
        
#         return list_all_sublist           # Повертаємо *list_all_sublist . Буде містити список з прожнім підсписком. *[[]]. Після повернення з функції  припиняє відразу роботу.
    
#     list_all_sublist.append ( [] )        # Якщо аргумент переданий в функцію не пустий список . То додаємо перший елемент в наш список порожній підсписок .
#                                           #  Визначено умовами завдання .
   
#     for i in  range( len ( data )) :      # Цикл в якому проходимся по індексу переданого в функціяю списку . З 0 елементу до довжини переданого списку *data
#                                           # Формуємо наш підсписок *sublist який будемо добавляти в основний список *list_all_sublist зрізом з одного елемента з списку *data
        
#         sublist = data [ i : i+1 ]        # *data [ i : i+1 ] - зріз з одного елементу . де data вхідний список . 
#                                           # *i - індекс поточного елемента з списку . 
#                                           # *i+1 наступний елемент списка невключається в зріз. 
#                                           # Зріз повертає список утворений з елементів вказаних в зрізі .Тобто в *sublist присвоюємо список утворений з 1 елемента який є поточний в циклі.
#                                           # Для нашого тестовго завдання . буде набувати наступних значень - [4], [6], [1], [3]                                     
#         list_all_sublist.append ( sublist )  # Добавляємо наш підсписок в основний список
    
#     for i in  range ( len ( data ) ) :   #  Робить все те саме щой і попередній цикл тільки беремо зріз з двох елементів 
#                                          # Має додаткову переврку на довжену підсписка щоб виключити попадання підсписків з довжиною 1 елемнт які можуть  утворяться в процесі . 
#                                          # Нам вони непотрібні їх ми записали всі в попередньому циклі. 
        
#         sublist = data [ i : i+2 ]       #  Для нашого тестовго завдання . буде набувати наступних значень - [4, 6], [6, 1], [1, 3]
        
#         if len ( sublist ) > 1 :         # Перевіряємо чи поточний підсписок має два елементи.Якщо так добавляємо їх в основиний список *list_all_sublist

#             list_all_sublist.append ( sublist )   # Добавляємо поточний елемент в основний список.

#             #print ( list_element_sublist)
#     for i in  range( len ( data ) ) :      # Робить все те саме щой і попередній цикл тільки беремо зріз з трьох елементів 
        
#         sublist = data [ i : i+3 ]       # Для нашого тестовго завдання . буде набувати наступних значень - [4, 6, 1], [6, 1, 3]
        
#         if len ( sublist ) > 2 :         #  Перевіряємо чи поточний підсписок має три елементи.Якщо так добавляємо їх в основиний список *list_all_sublist

#             list_all_sublist.append ( sublist )  # # Добавляємо поточний елемент в основний список.
    
#     list_all_sublist.append ( data )  # Добавляємо в кінці ще і сам переданий в функцію список. 
#                                       # В кінці наш список буде містити напочатку пустий підсписок ,ддалі всі підсписки з одного елемента , всі підсписки з двох елементів , всі підсписки з трох елементів і підсписок переданий в функцію. 
    
#     # print (list_sublist)
#     # print ( list_all_sublist )

#     return list_all_sublist  # Повертаємо з функції наш основний список.
#                              # Для нашого прикладу  [[], [4], [6], [1], [3], [4, 6], [6, 1], [1, 3], [4, 6, 1], [6, 1, 3], [4, 6, 1, 3]]


 



# data = [4, 6, 1, 3] # Тестове значення.
# # data = []         # Тестове значення.

# print ( all_sub_lists ( data ) )  # Принтане - [[], [4], [6], [1], [3], [4, 6], [6, 1], [1, 3], [4, 6, 1], [6, 1, 3], [4, 6, 1, 3]]


# ================================ Звдання 10 / Task 10 ======================================

#                                 Робота з словниками .(dict) for JSON.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# При роботі веб-сервісів спілкування, за протоколом HTTP, найчастіше відбувається в форматі JSON. 
# І надсилання даних на сервер при запиті POST - це необхідність використовувати словник, оскільки структура формату JSON ідентична словнику Python.

# Реалізуйте допоміжну функцію, яка формуватиме запит на сервер у вигляді словника. 
# Дана функція make_request(keys, values) приймає два параметри у вигляді списків. 
# Функція повинна створити словник із ключами з списку keys та значеннями зі списку values.

# Порядок відповідності збігається з індексами списків keys та values.
# Якщо довжина keys та values не збігаються, поверніть порожній словник.


# ++++++++++++++++++++++++++++++++++  Код /Code  +++++++++++++++++++++++++++++++++++++++++++++++++

# def make_request ( keys, values ) : # Функція отримує два аргументи увиглядів списків. Перший keys - список ключів , Другий - values - список занчень.
#                                     #  Порівнює довжину цих списків . Якщо вони не однакові повернути пустий словник. 
#                                     #  Якщо однаковий потрібно утворити словник з ключів і значень у відповідності до умови завдання.

#     price_dict = {}    # Список в який будемо вормувати наші пари ключи і відповідне значення. Початкова значення пустий словник.

#     if len ( keys ) != len ( values ) : # Перевіряєм чи довжина списку *keys не дорівню довжині списку *values . Якщо недорівню повртаємо пустий словник.

#         return price_dict   #   Повертаємо з фінкції пустий словник . Поточне значення словника price_dict = {} 
    
#     price_dict = dict ( zip ( keys , values ) ) # Задопомогою вбудованої функції *dict та вкладеної в неї функції *zip( *list , *list ) Формуємо словник 
#                                                 # де *keys - список ключів , *values список відповідних значень.
   
#     return price_dict  #    Повертаємо з фінкції сформований словник який відповідає умовам завдання.



# keys = ["toy" ,"peg_top", "doll", "ball", "jump rope"]  #  Тестові значення.

# values = ["100","200","500","200","50"] #  Тестові значення.

# print ( make_request ( keys, values ) )  #  Для наших тестових занчень принтить - {'toy': '100', 'peg_top': '200', 'doll': '500', 'ball': '200', 'jump rope': '50'}


# ================================ Звдання 11 / Task 11 ======================================

# #                                   Метод translate у Python 

# #     Метод translate у Python дозволяє замінити символ у рядку на інший з карти (таблиці) відповідності, яку можна створити заздалегідь. 
# # Якщо ми використовуємо словник, ми повинні використовувати ASCII коди замість символів.

# Приклад:

# replace_dict = {117: "o"}
# txt = "sun"
# print(txt.translate(replace_dict))  # son
# Що сталося? Ми замінили в тексті символ "u" на символ "o". Значення 117 - це ASCII код символу 'u', яке, як ми знаємо, 
# можна отримати за допомогою функції ord("u")

# replace_dict = {ord("u"): "o"}
# txt = "sun"
# print(txt.translate(replace_dict))  # son
# Таким чином translate() — метод, який повертає рядок, де деякі задані символи замінюються на символи, 
# описані у словнику або таблиці відображення. Якщо символ не вказано у словнику/таблиці, символ не буде замінено. 
# Для створення таблиці відображення використовується метод maketrans.

# txt = "sun"
# my_table = txt.maketrans("u", "o")
# print(txt.translate(my_table))  # son
# Можна визначити набір для замін

# txt = "sun"
# my_table = txt.maketrans("nus", "mot")
# print(txt.translate(my_table))  # tom
# Третій параметр у таблиці зіставлення описує символи, які ви хочете видалити з рядка:

# txt = "the sun"
# my_table = txt.maketrans("nus", "nos", "he t")
# print(txt.translate(my_table))  # son
# Якщо ми збираємося транслювати кирилицю на латиницю, у нас може виникнути проблема, наприклад, при транслітерації слова "чаша", 
# воно має стати "chasha" і мати довжину на два символи більше. Якщо використати maketrans, то це викличе помилку. Як бути?

# Для цього можна використати вбудовану функцію zip, яка перетворює чисельні об'єкти, що ітеруються в єдиний об'єкт кортежів для ітерування,
# та який буде складатись з відповідних елементів:

# CYRILLIC = ("а", "ч", "ш")
# LATIN = ("a", "ch", "sh")

# TRANSLIT_DICT = {}

# for c, l in zip(CYRILLIC, LATIN):
#     TRANSLIT_DICT[ord(c)] = l
#     TRANSLIT_DICT[ord(c.upper())] = l.upper()

# print("чаша".translate(TRANSLIT_DICT))  # chasha
# print("ЧАША".translate(TRANSLIT_DICT))  # CHASHA
# Так швидко можна створити словник для транслітерації. Якщо списки мають різні довжини, то функція zip припинить роботу, 
# щойно закінчиться перший із них.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Як ви знаєте, раніше телефони були з кнопками, та й зараз вони є подекуди у вжитку. 
# Тоді текстові повідомлення набиралися за допомогою цифрових кнопок. Як інженери телефонів створили набір тексту? 
# Рішення було в тому, що одна кнопка була асоційована одночасно з декількома літерами, а вибір залежав від кількості натискань на кнопку. 
# Одноразове натискання призводило до появи першої літери у відповідному цій кнопці списку, наступні натискання змінювали її на наступну.

# Символи, що відповідають кнопкам на телефонах

# Кнопка	Символи
# 1	. , ? ! :
# 2	A B C
# 3	D E F
# 4	G H I
# 5	J K L
# 6	M N O
# 7	P Q R S
# 8	T U V
# 9	W X Y Z
# 0	Пробіл
# Напишіть функцію sequence_buttons, що показує послідовність кнопок, яку необхідно натиснути, 
# щоб на екрані телефону з'явився текст, введений користувачем.

# Створіть словник, який відповідає символам з кнопками, які потрібно натиснути.

# Приклад: якщо функції sequence_buttons передати рядок "Hello, World!", функція повинна повернути "4433555555666110966677755531111".


# Вимоги:

# функція коректно обробляє малі та великі літери.
# функція ігнорує символи, що не входять до зазначеного списку


# ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++

# TRANS = { "1" : [ '.', ',', '?', '!', ':' ],
#           "2" : [ 'A', 'B', 'C' ],
#           "3" : [ 'D', 'E', 'F' ],
#           "4" : [ 'G', 'H', 'I' ],
#           "5" : [ 'J', 'K', 'L' ],
#           "6" : [ 'M', 'N', 'O' ],
#           "7" : [ 'P', 'Q', 'R', 'S' ],
#           "8" : [ 'T', 'U', 'V' ],
#           "9" : [ 'W', 'X', 'Y', 'Z' ],
#           "0" : [ ' ' ]


# }  # Словник в якому символи, що відповідають кнопкам на телефонах . Де ключами є кнопки телефону . а значеннми списки з символів які можна набрати цими кнопками.
#    # Де перший символ натискаєш один раз відповідну кнопку , другий символ з списку треба два рази натиснути цю ж кнопку і так дальше .

# def TRANS_REVERSE ( TRANS ) : # Допоміжна функція . в якій будемо створювати реверсний словник *TRANS_REVERSE_dict до нашого TRANS і повртати його з функції.
#                               # приймає один аргумент словник з якого будемо робити реверс.
#                               #  Реверсний словник  *TRANS_REVERSE_dict буде містити ключами всі символи з списку а значенням стане відповідний ключ для всіх цих значень.
      

#     TRANS_REVERSE_dict = {}  # Пустий словник в який будемо записувати наш реверсний.
    
#     for keys , values in TRANS.items () : # Цикл в якому проходимось по парам ключ - *keys і відповідне значення - *values . Метод *імя_словник.items () - повертає ключі і їх відповідні значення з словника.

#         TRANS_REVERSE_dict.update ( dict.fromkeys ( values , keys ) ) # Добавляємо в наш словник *TRANS_REVERSE_dict методом *імя_словника.update ( dict.fromkeys ( values , keys ) ) 
#                                                                       # і в будованою функцією *dict з методом .fromkeys ( *list , *значення (може бути довільний тип *str , list , dict і так далі) . 
#                                                                       # метод *.fromkeys - з списку ключів і значення формує новий ключ : значення . 
#                                                                       #  *.fromkeys (*list ,*str) Приймає два аргументи . Перший список ключів , другий їх майбутнє значення.   
#                                                                       # *dict.fromkeys ( values , keys )   # Де *values стане ключами  а *keys  - значенням для цих ключів.
# # Для нашого *TRANS -> *TRANS_REVERSE_dict буде мати такий вигляда = 
# # TRANS_REVERSE_dict = {
#         #     '.': '1', ',': '1', '?': '1', '!': '1', ':': '1', 'A': '2', 'B': '2', 'C': '2', 
#         # 'D': '3', 'E': '3', 'F': '3', 'G': '4', 'H': '4', 'I': '4', 'J': '5', 'K': '5', 'L': '5', 'M': '6', 'N': '6', 'O': '6', 
#         # 'P': '7', 'Q': '7', 'R': '7', 'S': '7', 'T': '8', 'U': '8', 'V': '8', 'W': '9', 'X': '9', 'Y': '9', 'Z': '9', ' ': '0'
#         # }
    
    
#     return TRANS_REVERSE_dict  # Повертаємо реверсний словник з фінкції

# def sequence_buttons ( string ) : # Основна функція . Отримує один аргумент типу *str- рядок . Повертає також рядок з кнопок , 
#                                   # який сладається з послідовності цифр які відповідають скільки раз яку кнопку треба натиснути на телефоні 
#                                   # щоб утворився переданий у функцію рядок.

#     TRANS_REVERSE_dict = TRANS_REVERSE ( TRANS ) # в *TRANS_REVERSE_dict  присвоюєм значення реверсного словника поврнутого з допоміжної функції *TRANS_REVERSE ( TRANS ) 
    
#     telefon_numers_code = ''            #  Рядок в який будемо записувати послідовність кнопок які треба натиснути що набрати тестове повідомлення *string      
    
#     string = string.upper()             # Переводиво всі символи в вхідному рядку в верхній регістр методом *імя_рядка.upper(). Якщо символ не буква передає його без змін.

#     for symbol in string :              # Цикл в якому будемо проходитись по нашому повідомлені нормалізованого до верхнього регістру.

#         # symbol =  f"{symbol}"
        
#         if symbol in TRANS_REVERSE_dict.keys() :    # Перевірємо чи поточний символ *symbol є серед ключів з  нашого реверсного словнику *TRANS_REVERSE_dict
#                                                     # Метод *імя_словника.keys() - повертає список ключів з нашого словника.

#             # print (symbol)
#             list_latter = TRANS [ TRANS_REVERSE_dict [ symbol ] ] # Якщо поточний символ *symbol є в списку ключів то вже з нашого словника *TRANS
#                                                                   # за кючем *TRANS_REVERSE_dict [ symbol ] повертаємо список значень в список *list_latter з словника *TRANS
#                                                                   #  Для ключа "1" значення  [ '.', ',', '?', '!', ':' ] 
#                                                                   #  Для ключа "2" значення [ 'A', 'B', 'C' ] і так далі.
#             # print ( list_latter)
#             count = 0 #                 Лічиьник яким будемо рахувати скльки раз треба натиснути відповідну  кнопку щоб отримати поточний символ *symbol

#             for elm in list_latter : #  Цикл в якому будемо проходитись по поточному списку *list_latter льчильни буде рахувати яка буква за порядком з списку 
#                                      #   відповідає нашому поточному списку. Визначену кнопку будемо записуватив наш рядок *telefon_numers_code - стільки разів скільки буде містити лічичльник *count

#                 count += 1          # Збільшуємо лічильник на один кожний раз коли проходить ітерація циклу.

#                 if elm == symbol : # Перевіряємо чи поточний елемент з списку *list_latter дорівнює нашому потчоному символу *symbol
#                                    #  Якщо так то в нашому *count - буде міститись кількісь раз скльки треба натиснути нашу кнопку з відповідною цифорою щоб отримати поточний символ.  

#                    telefon_numers_code += TRANS_REVERSE_dict [symbol] * count  # Записуємо поточну кнопку в наш рядок *telefon_numers_code помноживши поточне значення кнопки на *count.
#                                                                                # Для першої букви з нашого *string 'H'  буде 44
#                                                                                # Для другої букви з нашого *string 'e'  буде 33
#                                                                                # Для третьої букви з нашого *string 'l' буде 555 і так далі.

#                    break                            # Перериваємо наш вбудований цикл оператором *break  оскльки нам непотрібно проходитись по всіх елементах списку *list_latter а тільки порахувати скільки раз потрібно натиснути відповідну кнопку щоб отримати поточний символ.

#     return telefon_numers_code  # В кінці повертаємо утворений рядок з послідовністю кнопок які треба натиснути щоб отримати передане у функцію повідомлення *string 


# string = "Hello, World!"   # Тестове занчення 

# # print ( TRANS_REVERSE ( TRANS ) ) # Принт реверсного словника 

# print ( sequence_buttons ( string ) )  ,# Принт повернутого рядка для нашого тестового значення - "4433555555666110966677755531111"




# ================================ Звдання 12 / Task 12 ======================================

#=====================Робота з файлами , дозапис у файл , Зчитування з вказаного місця потрібну кількість символів.=============
#======================== метод .seek( *int )- встановлює курсор на вказане місце  ====================================

# Додаток може виконати багато операцій між відкриттям та закриттям файлу. В будь-якому місці може статися помилка та додаток завершиться аварійно,
# не повернувши файловий дескриптор системі. Така поведінка, як вже згадувалося, небажана і може призводити до втрати даних.

# Щоб уникнути цього, можна укласти блок коду, в якому відбувається робота з файлом, у блок try ... except:

# fh = open('text.txt')
# try:
#     some_useful_function(fh)
# finally:
#     fh.close()
# В цьому прикладі ми викликали функцію some_useful_function всередині блоку try ... except і, якщо станеться виключення, 
# то обов'язково виконається блок finally, в якому файл буде закритий. Цей підхід гарантує, 
# що файловий дескриптор буде обов'язково повернений системі.

# Але такий підхід не надто елегантний та читабельний.

# Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту open. 
# Менеджер контексту — це синтаксична конструкція, яка покращує читабельність коду, але не вносить ніякого додаткового функціоналу.

# with open('text.txt', 'w+') as fh:
#     some_useful_function(fh)
# Менеджер контексту складається з ключового слова with, після якого викликається сам менеджер і, 
# якщо щось треба повернути з менеджера, то це щось можна передати у змінну, оголошену після ключового слова as.
# Далі ставиться двокрапка і блок коду, який буде виконаний всередині менеджера. У прикладі з try ... finally — це код, 
# який йде всередині блоку try. Коли код винається, менеджер контексту виконає те, що повинен зробити в будь-якому випадку, 
# закрити файл наприклад (це те, що відбуваєтья в блоку finally).

# Менеджер контексту open синтаксично повністю повторює свого класичного тезка open, вони повністю ідентичні з точки зору використання.

# З точки зору роботи, цей приклад робить у точності теж саме, що і попередній з блоком try ... finally.
#  Але замість п'яти рядків коду, ви можете написати два, і код виглядає більше читабельним.

# Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# Реалізуйте функцію file_operations(path, additional_info, start_pos, count_chars), 
# яка додає додаткову інформацію в файл на шляху path з параметра additional_info, 
# і після цього повертає рядок з позиції start_pos довжиною count_chars.

# Вимоги:

# функція повинна відкривати файл за допомогою with за шляхом path в режимі додавання інформації
# записувати в кінець файлу рядок additional_info
# після запису функція має відкрити той самий файл для читання
# прочитати та повернути рядок з позиції start_pos завдовжки count_chars за допомогою функції seek.
# Важливо: для проходження завдання необхідно використовувати менеджер контексту with, методи seek, write та read.


# ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++

# from pathlib import Path

# def file_operations ( path, additional_info, start_pos, count_chars ) : # Функція  яка додає додаткову інформацію (рядок *additional_info) в файл на який вказує - *path , 
#                                                                         # і після цього повертає рядок з позиції start_pos довжиною count_chars.


#     with open ( path, "a" ) as fh :       # Відкриваємо наш файл на який вказує *path за допомогою менеджера контексту with на дозапис .
#                                           # *"a" - параметер який вказує що файл потрібно відкрити на дозапис. 
#                                           # Де fh - це хендлер в якому буде міститись    
        
#        fh.write ( additional_info )       # За допомогою методу *імя_хендлер.write (*str) - Метод .write() запише в кінець нашого файлу рядок який міститься в зміній *additional_info
#                                           # Оскільки наш файл був відкритий з параметром  "a" - дозапис в кінці файлу.
#                                           #  Після виходу з блоку  *with open ( path, "a" ) as fh : - наш файл закриється і дозаписана інформація збережеться у файлі.
       
       

#     with open ( path, "r" ) as fhr :       # Відкриваємо наш файл на який вказує *path за допомогою менеджера контексту with на читання .
#                                            # *"r" - параметер який вказує що файл буде відкритий для читання . 
     
#         fhr.seek ( start_pos )             # Встановлюємо курсор на позицію яка вказана в змінії *start_pos за допомогою методу *.seek ( *int )
#                                            # *імя_хендлеру.seek ( *число_на_яке_потрібно_змістити_курсор  ). Як тільки файл відкрився для читання курсор знаходиться на 0 позиції .
#                                            # 0- позиція це початок файлу . Перший записаний символ буде на 1 позиції. 

#         start_pos_count_chars = fhr.read ( count_chars ) # З місця де встановлений курсор читає ту кількість символів(1 символ = 1 байту по замовчуванню) на яку вказує зміна *count_chars
#                                                         #   Метод *.read ( *int ) - зчитує з хендлера , який містить файл який читаємо , ту кількість байт яка вказана як аргумент. 
#                                                         #  Якщо клькість невказана то зчитує весь файл по символьно. Зчитаний рядок присвоюємо змінній *start_pos_count_chars

#         return start_pos_count_chars                # Повертаємо з фінкції зчитаний рядок.
        





# path = Path ( 'Task_12_Chek_file.txt' )  # Присвоюємо зміній *path відносний шлях до файла 'Task_12_Chek_file.txt'  за допомогою фінкції Path яку напочатку коду імпортували з  бібліотеки pathlib
#                                          # Відносний шлях до файла -  це шлях до файла який знаходиться в тій самій папці що і файл з кодом який виконуємо.
# additional_info = "\n Але такий підхід не надто елегантний та читабельний." # тестовий рядок який будемо дозаписувати у наш файл.

# start_pos = 5 # Тестове значення місця з якого будемо читати наш файл.

# count_chars = 12 # Тестове значення кількості символів які будемо читати з місця де встановлений курсор.

# print ( file_operations ( path, additional_info, start_pos, count_chars ) ) # Принтимо отриманий рядок з нашої фінкції.



# ================================ Звдання 13 / Task 13 ======================================

#=====================Робота з файлами , ПОШУК ДАНИХ У ФАЙЛІ =============

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є файл зі списком працівників компанії. У кожному рядку файлу записано інформацію лише одного співробітника. 
# Формат запису, в межах навчання приймемо спрощений, такий як: ім'я співробітника, символ пропуску та його посада, тобто, ким він працює.

# John courier
# Pipe cook
# Створіть функцію get_employees_by_profession(path, profession). Функція повинна у файлі (параметр path) знайти всіх співробітників 
# зазначеної професії (параметр profession)

# Вимоги:

# відкрийте файл за допомогою with для читання
# отримайте рядки з файлу за допомогою методу readlines()
# за допомогою методу find знайдіть усі рядки у файлі, де є вказана profession, та помістіть записи до списку
# об'єднайте всі ці рядки в списку в один рядок за допомогою методу join (пам'ятайте про символ перенесення рядків '\n' та зайві прогалини,
# які треба прибрати)
# приберіть значення змінної 'profession' (замініть на порожній рядок "" методом replace)
# поверніть отриманий рядок із файлу

# ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++

# from pathlib import Path # Імпортуємо з бібліотеки pathlib функцію Path

# def get_employees_by_profession ( path, profession ) : # Функція отримує два аргументи. Перший *path шлях до вказаного файла в якому будемо проводити пошук .
#                                                        # Другий  *profession - містить професію яку будемо шукати у файлі. Тип *str .
#                                                        # Зчитуємо наш файл методом .readlines ()-повертає список з рядків файлу.
#                                                        # Шукаємо рядки в яких є нашае слово *profession . Обєднюємо знайдені рядки методом *.join( *list )
#                                                        # Форматуємо утворений рядок згідно умов завдання і повертаємо його з функції.

#     list_find_profession = []  # Список в який будемо добавляти знайдені рядки з файлу . Тобто ті в яких буде зустрічатись підрядок з зміної *profession

#     with open ( path , "r" ) as fhr : # Відкриваємо наш файл на який вказує *path методом контексту *with з параметром *"r" . *"r" - вікрити для читання
        
#         lines_string = fhr.readlines () # Записуємо в зміну *lines_string список який поверне метод *.readlines (). 
#                                         # Список з всіх рядків з файлу . Кожен рядок буде містити в кінці *'\n'- символ переносу на новий рядок.

#         #print ( lines_string )
       
#         for line in lines_string : # Цикл в якому будемо проходитись по списку *lines_string і перевіряти чи містить наш рядок підрядок з зміної *profession

#             if line.find ( profession ) >= 0 : # Перевіряємо чи міститься наш підрядок в поточному рядку чрез метод *.find (*str )
#                                               # Метод *імя_рядка_в_якому_шукаємо_підрядок.find ( *підрядок_який_шукаємо ) - повертає індекс першого входження першого символ у з підрядка у рядку . 
#                                               # Якщо підрядок незнайдений в рядку то повертає *-1 . Тобто якщо метод line.find ( profession ) буде більший - рівний 0 значить метод *.find(*str) - знайшов наш підрядок в поточному рядку.  
                          
#                 list_find_profession.append ( line ) # Добавляємо наш поточний підрядок в список *list_find_profession Методом *.append ( *дані )
            
#         #print (list_find_profession)
        
#         string_find_profession = "".join ( list_find_profession ) # Склеюємо всі наші рядки з списку *list_find_profession в онин рядок методом *join .
#                                                                 # *''.join ( list_find_profession ) 
#                                                                 # В нашому випадку склеюємо по символу пустого рядка ''. *'' - пустий рядок (підрядок через який склеювати елементи списку)
#                                                                 #  *.join () - сам метод. 
#                                                                 #  *list_find_profession - список який терба обєднати в один рядок.
        

#         format_string_find_profession = string_find_profession.replace ( '\n', '' ) # Замініяємо в нашому рядку *string_find_profession всі символи нового  рядка *\n на пустий символ *'' методом *.replace ( *str, *str )
#                                                                                     # метод *імя_рядка.replace ( *підрядок_який_треба_замінити_в_рядку, *підрядок_на_який_міняємо)
#                                                                                     # В *format_string_find_profession буде міститись наш рядко без символів *'\n'

#         format_string_find_profession = format_string_find_profession.replace ( profession , '' ) # В *format_string_find_profession буде міститись наш рядок без підрядка з *profession

#         format_string_find_profession = format_string_find_profession.strip() # Видаляємо можливі зайві пробіли з нашого рядка *format_string_find_profession за допомогою методу *.strip() 
#                                                                               # Метод *.strip(*str) - видаляє з початку і з кінця рядка вказаний пірядок . Якщо підрядок невказаний видаляє символи пробілів *" ". 
#         #print (format_string_find_profession)

#         return format_string_find_profession  #  Повертаємо з фінкції наш відформатований рядок згідно умов завдання.
    



# path = Path ( "Task_13_employees_by_profession.txt" )  # Шлях на файл з якого зчитуємо інофрмацію

# # profession = "courier"  # # Тестове знвчення

# profession = "cook"  # Тестове знвчення

# print (  get_employees_by_profession ( path, profession ) )  # Принтимо результат роботи функції з тестових значень.


# ================================ Звдання 14 / Task 14 ======================================

#===================== Робота з файлами , ЗМІНА ФАЙЛІВ. =============

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Напишіть функцію to_indexed(source_file, output_file), яка зчитуватиме вміст файлу, 
# додаватиме до прочитаних рядків порядковий номер і зберігати їх у такому вигляді у новому файлі.

# Кожний рядок у створеному файлі повинен починатися з його номера, двокрапки та пробілу, після чого має йти текст рядка з вхідного файлу.

# Нумерація рядків іде від 0.

# ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++


# from pathlib import Path # Імпортуємо з бібліотеки pathlib функцію Path

# def to_indexed ( source_file, output_file ) :  # Функція  яка зчитуватиме вміст файлу на який вказує *source_file, 
#                                                # додаватиме до прочитаних рядків порядковий номер і зберігати їх у такому вигляді у новому файлі на який вказує *output_file.
    
#     with open ( source_file, "r" ) as fhr :  # Відкрити файл на який вказує шлях *source_file для читання . Після завершення всіх маніпуляції закрити.
        
#         lines_string = fhr.readlines ()   # Зчитуємо всі наші рядки з файлу за допомогою методу *.readlines (). Цей метод з читує всі рядки з файлу і повертає спискок де елементом списку є зчитаний рядок.
#                                         #   *lines_string - буде містити спискок рядків з файлу *source_file
#     with open ( output_file, "w" ) as fhw : # Відкрити файл на який вказує шлях *output_file для запису . "w" - параметер відкриває файл для запису . Все що було файлі до того витреться.

#         count = 0                          # Лічильник яким будемо ряхувати кількість рядків в файлі *source_file
        
#         for line in lines_string :  # Цикл в якому будемо проходитись по списку *lines_string - (який містить всі рядки прочитані з *source_file )
#                                     #  і добавляти в поточний рядок на початок індекс рядка після нього відразу двокрапку : і після двокрапки пробіл " "
#                                     # Поточний змінений рядок вілразу записуємо у новий файл.
           
#             line = f"{count}: {line}" # Формуємо новий рядок для запису у файл *output_file . Приклад вхідний рядок був "John courier" а стане "0: John courier"

#             fhw.writelines ( line )   # Записуємо сформаваний рядок у файл методом *.writelines ( *str )

#             count += 1  #  Збільшуємо наш лічильник на 1 . Вкінці циклу наш файл закриється вміст збережеться Оскільки ми використали  оператор контексту *with
          

# # ++++++++++++++++++++++++++++++++++  Код /Code який приймає автопереврка . Про те працює на мою думку незовсім коректно бо дописує в кінці останього рядка "{count+1}: "+++++++++++++++++++++++++++++++++++++++++++++++++

# # def to_indexed(source_file, output_file):
# #   num_str = 0
# #   out = []
# #   with open(source_file, 'r') as hfr:
# #     while True:
# #       try:
# #         output_str = hfr.readline()
# #         if not output_str:
# #           break
# #       except:
# #         return None
# #       finally:
# #         try:
# #           out.append(str(num_str)+': '+output_str)
# #         except:
# #           return None
# #       num_str += 1
# #   with open(output_file, 'w') as hfw:
# #     for line in out:
# #       hfw.write(line)
  
# #   return True

# source_file = Path ( 'Task_14_source_file.txt' )  # Шлях до тестовго файла з якого читаємо  

# output_file = Path ( 'Task_14_output_file.txt' )  # Шлях до тестовго файла в який записуємо


# to_indexed ( source_file, output_file ) # Виклик функції *to_indexed ( source_file, output_file ) . функція нічого не повертає тому непринтемо.



# ================================ Звдання 15 / Task 15 ======================================

#===================== Робота списками, Рекурсія . flatentening -Це процес вирівнювання списків, який полягає в позбавленні вкладеної структури=============

# Повторюємо рекурсію.

# Рекурсією ми називаємо технологію виклику функцією самої себе. Така функція називається рекурсивною. 
# Оскільки в описі функції існує вказівка на саму себе, їй необхідно прийти до підсумкового розв'язку, інакше ми отримаємо нескінченний виклик. 
# Тому рекурсивна функція повинна хоча б один раз досягти кінцевого результату без само виклику себе. 
# Цей метод називають базовим випадком (base case), інші варіанти, у яких функція звертається сам до себе, 
# називають рекурсивними випадками (recursive case).

# Де рекурсія може знадобитись? На практиці рекурсію застосовують, коли стикаються, наприклад, з деревоподібними структурами даних:
# обхід каталогів на диску, низхідний спосіб граматичного аналізу для компілятора мови програмування. 
# Для пояснення ж використовують простіші приклади: підрахунок чисел Фібоначчі або розрахунок факторіала і т.д. 
# Не порушуватимемо традиції та розберемо рекурсію на прикладі факторіала.

# Нагадаємо, що факторіал - функція визначена на множині додатних цілих чисел.

# n! = 1 · 2 · ... · n

# 0! = 1

# Приклад:

# # Обчислюємо факторіал числа n за допомогою рекурсії
# # @param n – число, для якого треба розрахувати факторіал
# # @return факторіал числа n
# def factorial(n):
#     if n < 2:
#         return 1  # Базовий випадок
#     else:
#         return n * factorial(n - 1)  # Рекурсивний випадок


# num = int(input("Введіть додатне ціле число: "))
# result = factorial(num)
# print(f"Факторіал числа {num} дорівнює {result}")
# За допомогою оператора if ми визначаємо, з яким випадком ми маємо справу - з базовим або рекурсивним. 
# У базовому випадку ми повертаємо одиницю і функція не викликає саму себе. У гілці else відбувається рекурсивний випадок і 
# функція викликається повторно зі зменшеним аргументом (n – 1).

# Повернене з рекурсії значення множиться на n. У результаті ми маємо отримати факторіал числа n, 
# який і буде повернений як результат функції factorial.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Рекурсія добре підходить до задачі flatentening. Це процес вирівнювання списків, який полягає в позбавленні вкладеної структури. 
# Наприклад список вигляду [1, 2, [3, 4, [5, 6]], 7] має бути перетворений на плоский (flat) список [1, 2, 3, 4, 5, 6, 7]

# Напишіть функцію flatten, яка приймає на вхід список, рекурсивно вирівнюватиме цей список і повертатиме пласку версію списку.

# Для виконання завдання можна дотримуватися наступного алгоритму:

# Якщо вхідний список порожній, то:
#   Повертаємо порожній список
# Якщо перший елемент списку є списком, то:
#   Отримуємо перший список, рекурсивно викликавши функцію з першим елементом списку
#   Отримуємо другий список, рекурсивно викликавши функцію з рештою списку без першого елемента
#   Повертаємо конкатенацію двох списків
# Якщо перший елемент списку не є списком, то:
#   Отримуємо перший список із першого елемента списку
#   Отримуємо другий список, рекурсивно викликавши функцію з рештою списку без першого елемента
#   Повертаємо конкатенацію двох списків

# ++++++++++++++++++++++++++++++++++  Код /Code +++++++++++++++++++++++++++++++++++++++++++++++++

def flatten ( data ) :  # Рекурсивна функція приймає в нашому випадку спискок з вкладеними списками  [1, 2, [3, 4, [5, 6]], 7]
                        #  Повертає плоский список без вкладених списків [1, 2, 3, 4, 5, 6, 7]
                        #  Завдання зроблемно по запропонованому алгоритму . Як воно працює до кінця не усвідомлю . Розбирусь колись пізніше. Наведу результати на кожному кроці виконання коду.
    
    if data == [] :  #
        return data  #
    
    list_flatten_1 = [] #
    list_flatten_2 = [] #

    if type( data[0] ) == list :  #

            list_flatten_1 = flatten ( data[0] )  #

            list_flatten_2 = flatten ( data[0+1:] ) #

            list_flatten = list_flatten_1 + list_flatten_2 #

            print (f"якщо спрацює if list_flatten_1 = {list_flatten_1}")
            print (f"якщо спрацює if list_flatten_2 = {list_flatten_2}")
            print (f"якщо спрацює if list_flatten = {list_flatten}")
            
            return list_flatten  #
    else :
         list_flatten_1.append( data[0] ) #

         list_flatten_2 = flatten ( data[0+1:] ) #

         list_flatten = list_flatten_1 + list_flatten_2 #
         print (f"якщо спрацює else list_flatten_1 = {list_flatten_1}")
         print (f"якщо спрацює else list_flatten_2 = {list_flatten_2}")
         print (f"якщо спрацює else list_flatten = {list_flatten}")

         return list_flatten #

# +++++++++++ Результати роботи коду покрокові. отримані принтами для нашого прикладу data = [1, 2, [3, 4, [5, 6]], 7]  +++++++
    
якщо спрацює else list_flatten_1 = [6] - найнижчий рівень рекурсії з якої все почне схопуватись позначемо крок 0. 
якщо спрацює else list_flatten_2 = [] - найнижчий рівень рекурсії з якої все почне схопуватись позначемо крок 0. 
якщо спрацює else list_flatten = [6]  - найнижчий рівень рекурсії з якої все почне схопуватись позначемо крок 0. 
якщо спрацює else list_flatten_1 = [5] - крок 1.
якщо спрацює else list_flatten_2 = [6] - крок 1.
якщо спрацює else list_flatten = [5, 6] - крок 1.
якщо спрацює if list_flatten_1 = [5, 6] - крок 2.
якщо спрацює if list_flatten_2 = [] - крок 2.
якщо спрацює if list_flatten = [5, 6] - крок 2.
якщо спрацює else list_flatten_1 = [4] -- крок 3.
якщо спрацює else list_flatten_2 = [5, 6] -- крок 3.
якщо спрацює else list_flatten = [4, 5, 6]-- крок 3.
якщо спрацює else list_flatten_1 = [3] -- крок 4.
якщо спрацює else list_flatten_2 = [4, 5, 6] -- крок 4.
якщо спрацює else list_flatten = [3, 4, 5, 6] -- крок 4.
якщо спрацює else list_flatten_1 = [7] -- крок 5.
якщо спрацює else list_flatten_2 = [] -- крок 5.
якщо спрацює else list_flatten = [7] -- крок 5.
якщо спрацює if list_flatten_1 = [3, 4, 5, 6] -- крок 6.
якщо спрацює if list_flatten_2 = [7]  -- крок 6.
якщо спрацює if list_flatten = [3, 4, 5, 6, 7]  -- крок 6.
якщо спрацює else list_flatten_1 = [2] -- крок 7.
якщо спрацює else list_flatten_2 = [3, 4, 5, 6, 7] -- крок 7.
якщо спрацює else list_flatten = [2, 3, 4, 5, 6, 7] -- крок 7.
якщо спрацює else list_flatten_1 = [1] -- крок 8.
якщо спрацює else list_flatten_2 = [2, 3, 4, 5, 6, 7] -- крок 8.
якщо спрацює else list_flatten = [1, 2, 3, 4, 5, 6, 7] -- крок 8 . - Кінцевий результат який повернеться з функції в кініці завершення всіх рекурсії.




data = [1, 2, [3, 4, [5, 6]], 7] # Тестовий приклад .

print ( flatten ( data ) )  #  Принтемо результат роботи функції для нашого прикладу буде [1, 2, 3, 4, 5, 6, 7].